
8_Frecuencia_timer_interrupciones.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000028  00800100  00000b98  00000c2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  00800128  00800128  00000c54  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00000c54  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000cb0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e0  00000000  00000000  00000cf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001c1e  00000000  00000000  00000dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000811  00000000  00000000  000029ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a68  00000000  00000000  000031ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000022c  00000000  00000000  00003c68  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005ba  00000000  00000000  00003e94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001155  00000000  00000000  0000444e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  000055a3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 12 01 	jmp	0x224	; 0x224 <__vector_1>
   8:	0c 94 31 01 	jmp	0x262	; 0x262 <__vector_2>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 b0 02 	jmp	0x560	; 0x560 <__vector_7>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 9e 02 	jmp	0x53c	; 0x53c <__vector_11>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	d0 01       	movw	r26, r0
  6a:	e4 01       	movw	r28, r8
  6c:	f8 01       	movw	r30, r16
  6e:	0c 02       	muls	r16, r28
  70:	20 02       	muls	r18, r16
  72:	34 02       	muls	r19, r20
  74:	48 02       	muls	r20, r24
  76:	5c 02       	muls	r21, r28
  78:	70 02       	muls	r23, r16
  7a:	84 02       	muls	r24, r20

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e8 e9       	ldi	r30, 0x98	; 152
  90:	fb e0       	ldi	r31, 0x0B	; 11
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a8 32       	cpi	r26, 0x28	; 40
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a8 e2       	ldi	r26, 0x28	; 40
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a4 33       	cpi	r26, 0x34	; 52
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 50 01 	call	0x2a0	; 0x2a0 <main>
  b2:	0c 94 ca 05 	jmp	0xb94	; 0xb94 <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <ENVIA_CMD>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  ba:	98 2f       	mov	r25, r24
  bc:	90 7f       	andi	r25, 0xF0	; 240
  be:	96 95       	lsr	r25
  c0:	96 95       	lsr	r25
  c2:	98 b9       	out	0x08, r25	; 8
  c4:	98 b1       	in	r25, 0x08	; 8
  c6:	9e 7f       	andi	r25, 0xFE	; 254
  c8:	98 b9       	out	0x08, r25	; 8
  ca:	98 b1       	in	r25, 0x08	; 8
  cc:	92 60       	ori	r25, 0x02	; 2
  ce:	98 b9       	out	0x08, r25	; 8
  d0:	ef e9       	ldi	r30, 0x9F	; 159
  d2:	ff e0       	ldi	r31, 0x0F	; 15
  d4:	31 97       	sbiw	r30, 0x01	; 1
  d6:	f1 f7       	brne	.-4      	; 0xd4 <ENVIA_CMD+0x1a>
  d8:	00 c0       	rjmp	.+0      	; 0xda <ENVIA_CMD+0x20>
  da:	00 00       	nop
  dc:	98 b1       	in	r25, 0x08	; 8
  de:	9d 7f       	andi	r25, 0xFD	; 253
  e0:	98 b9       	out	0x08, r25	; 8
  e2:	ef e3       	ldi	r30, 0x3F	; 63
  e4:	fc e9       	ldi	r31, 0x9C	; 156
  e6:	31 97       	sbiw	r30, 0x01	; 1
  e8:	f1 f7       	brne	.-4      	; 0xe6 <ENVIA_CMD+0x2c>
  ea:	00 c0       	rjmp	.+0      	; 0xec <ENVIA_CMD+0x32>
  ec:	00 00       	nop
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	88 0f       	add	r24, r24
  f2:	99 1f       	adc	r25, r25
  f4:	88 0f       	add	r24, r24
  f6:	99 1f       	adc	r25, r25
  f8:	8c 73       	andi	r24, 0x3C	; 60
  fa:	88 b9       	out	0x08, r24	; 8
  fc:	88 b1       	in	r24, 0x08	; 8
  fe:	8e 7f       	andi	r24, 0xFE	; 254
 100:	88 b9       	out	0x08, r24	; 8
 102:	88 b1       	in	r24, 0x08	; 8
 104:	82 60       	ori	r24, 0x02	; 2
 106:	88 b9       	out	0x08, r24	; 8
 108:	8f e9       	ldi	r24, 0x9F	; 159
 10a:	9f e0       	ldi	r25, 0x0F	; 15
 10c:	01 97       	sbiw	r24, 0x01	; 1
 10e:	f1 f7       	brne	.-4      	; 0x10c <ENVIA_CMD+0x52>
 110:	00 c0       	rjmp	.+0      	; 0x112 <ENVIA_CMD+0x58>
 112:	00 00       	nop
 114:	88 b1       	in	r24, 0x08	; 8
 116:	8d 7f       	andi	r24, 0xFD	; 253
 118:	88 b9       	out	0x08, r24	; 8
 11a:	ef e3       	ldi	r30, 0x3F	; 63
 11c:	fc e9       	ldi	r31, 0x9C	; 156
 11e:	31 97       	sbiw	r30, 0x01	; 1
 120:	f1 f7       	brne	.-4      	; 0x11e <ENVIA_CMD+0x64>
 122:	00 c0       	rjmp	.+0      	; 0x124 <ENVIA_CMD+0x6a>
 124:	00 00       	nop
 126:	08 95       	ret

00000128 <LCD_INICIALIZA>:
 128:	82 e0       	ldi	r24, 0x02	; 2
 12a:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 12e:	88 e2       	ldi	r24, 0x28	; 40
 130:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 134:	8e e0       	ldi	r24, 0x0E	; 14
 136:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 13a:	86 e0       	ldi	r24, 0x06	; 6
 13c:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 146:	80 e8       	ldi	r24, 0x80	; 128
 148:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 14c:	08 95       	ret

0000014e <ENVIA_DATO>:
 14e:	98 2f       	mov	r25, r24
 150:	90 7f       	andi	r25, 0xF0	; 240
 152:	96 95       	lsr	r25
 154:	96 95       	lsr	r25
 156:	98 b9       	out	0x08, r25	; 8
 158:	98 b1       	in	r25, 0x08	; 8
 15a:	93 60       	ori	r25, 0x03	; 3
 15c:	98 b9       	out	0x08, r25	; 8
 15e:	ef e9       	ldi	r30, 0x9F	; 159
 160:	ff e0       	ldi	r31, 0x0F	; 15
 162:	31 97       	sbiw	r30, 0x01	; 1
 164:	f1 f7       	brne	.-4      	; 0x162 <ENVIA_DATO+0x14>
 166:	00 c0       	rjmp	.+0      	; 0x168 <ENVIA_DATO+0x1a>
 168:	00 00       	nop
 16a:	98 b1       	in	r25, 0x08	; 8
 16c:	9d 7f       	andi	r25, 0xFD	; 253
 16e:	98 b9       	out	0x08, r25	; 8
 170:	98 b1       	in	r25, 0x08	; 8
 172:	9e 7f       	andi	r25, 0xFE	; 254
 174:	98 b9       	out	0x08, r25	; 8
 176:	ef e3       	ldi	r30, 0x3F	; 63
 178:	fc e9       	ldi	r31, 0x9C	; 156
 17a:	31 97       	sbiw	r30, 0x01	; 1
 17c:	f1 f7       	brne	.-4      	; 0x17a <ENVIA_DATO+0x2c>
 17e:	00 c0       	rjmp	.+0      	; 0x180 <ENVIA_DATO+0x32>
 180:	00 00       	nop
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	88 0f       	add	r24, r24
 186:	99 1f       	adc	r25, r25
 188:	88 0f       	add	r24, r24
 18a:	99 1f       	adc	r25, r25
 18c:	8c 73       	andi	r24, 0x3C	; 60
 18e:	88 b9       	out	0x08, r24	; 8
 190:	88 b1       	in	r24, 0x08	; 8
 192:	83 60       	ori	r24, 0x03	; 3
 194:	88 b9       	out	0x08, r24	; 8
 196:	8f e9       	ldi	r24, 0x9F	; 159
 198:	9f e0       	ldi	r25, 0x0F	; 15
 19a:	01 97       	sbiw	r24, 0x01	; 1
 19c:	f1 f7       	brne	.-4      	; 0x19a <ENVIA_DATO+0x4c>
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <ENVIA_DATO+0x52>
 1a0:	00 00       	nop
 1a2:	88 b1       	in	r24, 0x08	; 8
 1a4:	8d 7f       	andi	r24, 0xFD	; 253
 1a6:	88 b9       	out	0x08, r24	; 8
 1a8:	88 b1       	in	r24, 0x08	; 8
 1aa:	8e 7f       	andi	r24, 0xFE	; 254
 1ac:	88 b9       	out	0x08, r24	; 8
 1ae:	ef e3       	ldi	r30, 0x3F	; 63
 1b0:	fc e9       	ldi	r31, 0x9C	; 156
 1b2:	31 97       	sbiw	r30, 0x01	; 1
 1b4:	f1 f7       	brne	.-4      	; 0x1b2 <ENVIA_DATO+0x64>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <ENVIA_DATO+0x6a>
 1b8:	00 00       	nop
 1ba:	08 95       	ret

000001bc <ENVIA_CADENA>:
 1bc:	0f 93       	push	r16
 1be:	1f 93       	push	r17
 1c0:	cf 93       	push	r28
 1c2:	df 93       	push	r29
 1c4:	8c 01       	movw	r16, r24
 1c6:	c0 e0       	ldi	r28, 0x00	; 0
 1c8:	d0 e0       	ldi	r29, 0x00	; 0
 1ca:	03 c0       	rjmp	.+6      	; 0x1d2 <ENVIA_CADENA+0x16>
 1cc:	0e 94 a7 00 	call	0x14e	; 0x14e <ENVIA_DATO>
 1d0:	21 96       	adiw	r28, 0x01	; 1
 1d2:	f8 01       	movw	r30, r16
 1d4:	ec 0f       	add	r30, r28
 1d6:	fd 1f       	adc	r31, r29
 1d8:	80 81       	ld	r24, Z
 1da:	81 11       	cpse	r24, r1
 1dc:	f7 cf       	rjmp	.-18     	; 0x1cc <ENVIA_CADENA+0x10>
 1de:	df 91       	pop	r29
 1e0:	cf 91       	pop	r28
 1e2:	1f 91       	pop	r17
 1e4:	0f 91       	pop	r16
 1e6:	08 95       	ret

000001e8 <LIMPIA_LCD>:
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 1ee:	08 95       	ret

000001f0 <REGRESO_CASA>:
 1f0:	82 e0       	ldi	r24, 0x02	; 2
 1f2:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 1f6:	08 95       	ret

000001f8 <POS_LINEA1>:
 1f8:	80 68       	ori	r24, 0x80	; 128
 1fa:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 1fe:	08 95       	ret

00000200 <POS_LINEA2>:
 200:	80 6c       	ori	r24, 0xC0	; 192
 202:	0e 94 5d 00 	call	0xba	; 0xba <ENVIA_CMD>
 206:	08 95       	ret

00000208 <MENSAJE_INICIAL>:
//MENSAJE_INICIAL: Función normal para mostrar un mensaje inicial después o antes de que se haya activado una interrupción.
void MENSAJE_INICIAL(){
	//_delay_ms(750); //Retraso antirebote
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 208:	0e 94 94 00 	call	0x128	; 0x128 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 20c:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 210:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 214:	80 e0       	ldi	r24, 0x00	; 0
 216:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <POS_LINEA1>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("frecuencia led");
 21a:	88 e0       	ldi	r24, 0x08	; 8
 21c:	91 e0       	ldi	r25, 0x01	; 1
 21e:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
 222:	08 95       	ret

00000224 <__vector_1>:
/*Las acciones de las interrupciones externas deben ser descritas en una función fuera del método main, estas reciben como parámetro lo siguiente:
	- INT0_vect: Interrupción externa 0 después de haber sido configurada con los registros EIMSK y EICRA, esta está asociada al pin 2 (PD2) del Puerto D en el Arduino
	- INT1_vect: Interrupción externa 1 después de haber sido configurada con los registros EIMSK y EICRA, esta está asociada al pin 3 (PD3) del Puerto D en el Arduino.*/
//ISR INTERRUPCIONES EXTERNAS:
//INTERRUPCIÓN EXTERNA INT0 DEL PUERTO D; INT0	(Pin 2 del Puerto D): REPRESENTA AL BOTÓN - PARA BAJAR LA FRECUENCIA.
ISR(INT0_vect){
 224:	1f 92       	push	r1
 226:	0f 92       	push	r0
 228:	0f b6       	in	r0, 0x3f	; 63
 22a:	0f 92       	push	r0
 22c:	11 24       	eor	r1, r1
 22e:	8f 93       	push	r24
 230:	9f 93       	push	r25
	//CONDICIONALES QUE VEN SI SE PRESIONÓ UN BOTÓN PARA SUBIR O BAJAR LA FRECUENCIA E INDICAR ALGO EN EL LCD CUANDO SE HAYA ALCANZADO F_MIN Y F_MAX
	lista_frecuencias--; //Se reduce el valor de la lista de frecuencias.
 232:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <lista_frecuencias>
 236:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <lista_frecuencias+0x1>
 23a:	01 97       	sbiw	r24, 0x01	; 1
 23c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <lista_frecuencias+0x1>
 240:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <lista_frecuencias>
	
	//FIJAR EL MÍNIMO DE LAS FRECUENCIAS
	if(lista_frecuencias == 0){
 244:	89 2b       	or	r24, r25
 246:	31 f4       	brne	.+12     	; 0x254 <__vector_1+0x30>
		lista_frecuencias = 1; //Valor de lista_frecuencias regresado a su valor máximo permisible.
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <lista_frecuencias+0x1>
 250:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <lista_frecuencias>
	}
}
 254:	9f 91       	pop	r25
 256:	8f 91       	pop	r24
 258:	0f 90       	pop	r0
 25a:	0f be       	out	0x3f, r0	; 63
 25c:	0f 90       	pop	r0
 25e:	1f 90       	pop	r1
 260:	18 95       	reti

00000262 <__vector_2>:
//INTERRUPCIÓN EXTERNA INT1 DEL PUERTO D: INT1	(Pin 3 del Puerto D): REPRESENTA AL BOTÓN + PARA SUBIR LA FRECUENCIA.
ISR(INT1_vect){
 262:	1f 92       	push	r1
 264:	0f 92       	push	r0
 266:	0f b6       	in	r0, 0x3f	; 63
 268:	0f 92       	push	r0
 26a:	11 24       	eor	r1, r1
 26c:	8f 93       	push	r24
 26e:	9f 93       	push	r25
	//CONDICIONALES QUE VEN SI SE PRESIONÓ UN BOTÓN PARA SUBIR O BAJAR LA FRECUENCIA E INDICAR ALGO EN EL LCD CUANDO SE HAYA ALCANZADO F_MIN Y F_MAX
	lista_frecuencias++; //Se aumenta el valor de la lista de frecuencias.
 270:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <lista_frecuencias>
 274:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <lista_frecuencias+0x1>
 278:	01 96       	adiw	r24, 0x01	; 1
 27a:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <lista_frecuencias+0x1>
 27e:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <lista_frecuencias>
	
	//FIJAR EL MÁXIMO DE LAS FRECUENCIAS
	if(lista_frecuencias == 11){
 282:	0b 97       	sbiw	r24, 0x0b	; 11
 284:	31 f4       	brne	.+12     	; 0x292 <__vector_2+0x30>
		lista_frecuencias = 10; //Valor de lista_frecuencias regresado a su valor máximo permisible.
 286:	8a e0       	ldi	r24, 0x0A	; 10
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <lista_frecuencias+0x1>
 28e:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <lista_frecuencias>
	}
}
 292:	9f 91       	pop	r25
 294:	8f 91       	pop	r24
 296:	0f 90       	pop	r0
 298:	0f be       	out	0x3f, r0	; 63
 29a:	0f 90       	pop	r0
 29c:	1f 90       	pop	r1
 29e:	18 95       	reti

000002a0 <main>:
int main(void){
    /*CLI: Cuando se activa una CLI interruption, automáticamente el bit 7 del status register que es GI (General Interruption) se convierte en 0 lógico, lo que convierte a 
	las interrupciones en MI (Maskable Interrupt), esto en términos más simples significa que las interrupciones están activas:
		- Cuando GI tiene valor de 1 lógico no está activada ninguna interrupción, osea que es NMI, Non Maskable Interrupt.
		- Cuando GI tiene valor de 0 lógico está activada la interrupción, osea que es MI, Maskable Interrupt.*/
	cli(); //Evita cualquier interrupción que entre mientras ya se está ejecutando una o antes de programar la máquina, ya que termine, permite la ejecución de interrupciones.
 2a0:	f8 94       	cli
	
	
	//PROGRAMACIÓN DE LA MÁQUINA: Se indica por medio de los registros de función específica si los pines de los puertos serán entradas o salidas o el estado de los timers.
	//0: Pin como entrada
	//1: Pin como salida
	DDRB = (1<<DDB0);	//Pin 8	(PB0) del Puerto B como salida, frecuencia variable;				Temporizador T1.
 2a2:	81 e0       	ldi	r24, 0x01	; 1
 2a4:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF;		//Todos los pines del puerto C son salidas al LCD.
 2a6:	9f ef       	ldi	r25, 0xFF	; 255
 2a8:	97 b9       	out	0x07, r25	; 7
	DDRD = (1<<DDD0);	//Pin 0	(PD0) del Puerto D como salida, frecuencia de 0.5Hz;	T = 2s;		Temporizador T2.
 2aa:	8a b9       	out	0x0a, r24	; 10
		-	La instrucción |= lo que hace es asignar el valor 1 lógico a un bit específico de un número binario cualquiera sin afectar a los demás.
		-	La instrucción & es un AND, lo que crea es una máscara AND.
		-	La instrucción &= lo que hace es asignar el valor 0 lógico a un bit específico de un número binario cualquiera sin afectar a los demás.*/
	//MÁSCARA OR: Convierte en 1 todo lo que esté en contacto con los 1 de la máscara y deja pasar tal cual lo que esté en contacto con los 0 de la máscara.
	//MÁSCARA AND: Convierte en 0 todo lo que esté en contacto con los 0 de la máscara y deja pasar tal cual lo que esté en contacto con los 1 de la máscara.
	EIMSK |= (1<<INT0);	//Activación de la interrupción externa INT0 asociada al pin 2 (PD2) del Puerto D en el Arduino.
 2ac:	8d b3       	in	r24, 0x1d	; 29
 2ae:	81 60       	ori	r24, 0x01	; 1
 2b0:	8d bb       	out	0x1d, r24	; 29
	EIMSK |= (1<<INT1);	//Activación de la interrupción externa INT1 asociada al pin 3 (PD3) del Puerto D en el Arduino.
 2b2:	8d b3       	in	r24, 0x1d	; 29
 2b4:	82 60       	ori	r24, 0x02	; 2
 2b6:	8d bb       	out	0x1d, r24	; 29
		- ISC10: Bit 2 del registro EICRA, afecta a la interrupción externa INT1:
			- ISC11 = 0 y ISC10 = 0; Interrupción de nivel bajo, osea cuando la señal de factor externo se encuentra en 0 lógico.
			- ISC11 = 0 y ISC10 = 1; Interrupción con cambio de estado lógico en la señal, osea cuando la señal de factor externo cambia de 0 a 1 o 1 a 0.
			- ISC11 = 1 y ISC10 = 0; Interrupción de flanco de bajada, osea cuando la señal de factor externo cambia de 1 a 0.
			- ISC11 = 1 y ISC10 = 1; Interrupción de flanco de subida, osea cuando la señal de factor externo cambia de 0 a 1.*/
	EICRA |= (1<<ISC01)|(1<<ISC00); //INT0 del registro EIMSK configurada con los bits ISC01 e ISC00 del registro EICRA, activando la interrupción de flanco de subida.
 2b8:	e9 e6       	ldi	r30, 0x69	; 105
 2ba:	f0 e0       	ldi	r31, 0x00	; 0
 2bc:	80 81       	ld	r24, Z
 2be:	83 60       	ori	r24, 0x03	; 3
 2c0:	80 83       	st	Z, r24
	EICRA |= (1<<ISC11)|(1<<ISC10); //INT1 del registro EIMSK configurada con los bits ISC11 e ISC10 del registro EICRA, activando la interrupción de flanco de subida.
 2c2:	80 81       	ld	r24, Z
 2c4:	8c 60       	ori	r24, 0x0C	; 12
 2c6:	80 83       	st	Z, r24
		con 0 lógico se deja a los temporizadores T0 y T1 con el último valor de conteo que tenían y escala con la que se quedaron.
	Cuando es usa más de un timer para manejo de tiempos, es necesario usar este registro, además esto se debe hacer justo antes de configurar los timers, una vez 
	configurados, se debe volver este registro a que valga 0.
	No es tan importante usar el registro GTCCR cuando se usan interrupciones externas, pero cuando se hace con temporizadores si lo es, ya que puede evitar que falle el 
	programa, además cuando se usan varios temporizadores a la vez, deben usarse en Puertos diferentes, sino fallarán.*/
	GTCCR = (1<<TSM)|(1<<PSRASY)|(1<<PSRSYNC); //TSM -> Timers sincronizados; PSRASY -> Timer T2 reiniciado; PSRSYNC -> Timers T0 y T1 reiniciados.
 2c8:	83 e8       	ldi	r24, 0x83	; 131
 2ca:	83 bd       	out	0x23, r24	; 35
			- COM0A1 = 1
			- COM0A0 = 1
	La salida determinada con los pines del registro TCCR0A se verá en el pin 6	(PD6) del Puerto D, conectada a la salida OCR0A.*/
	//TCCR#A o registro de control del temporizador A: Sirve para indicar el tipo de salida y tipo de comparación en el temporizador T#, accede a los bits WMG#1 y WMG#0.
	//TIPO DE SEÑAL DE SALIDA CUADRADA:
	TCCR1A |= (1<<COM1A1)|(1<<COM1A0);	//Configuración Uno lógico en OC1 (Osea la señal de salida OCR#A y OCR#B); COM1A1 = 1, COM1A0 = 1
 2cc:	a0 e8       	ldi	r26, 0x80	; 128
 2ce:	b0 e0       	ldi	r27, 0x00	; 0
 2d0:	8c 91       	ld	r24, X
 2d2:	80 6c       	ori	r24, 0xC0	; 192
 2d4:	8c 93       	st	X, r24
	TCCR2A |= (1<<COM2A1)|(1<<COM2A0);	//Configuración Uno lógico en OC2 (Osea la señal de salida OCR#A y OCR#B); COM2A1 = 1, COM2A0 = 1
 2d6:	e0 eb       	ldi	r30, 0xB0	; 176
 2d8:	f0 e0       	ldi	r31, 0x00	; 0
 2da:	80 81       	ld	r24, Z
 2dc:	80 6c       	ori	r24, 0xC0	; 192
 2de:	80 83       	st	Z, r24
	//TIPO DE COMPARADOR - PARTE 1/2:
	TCCR1A |= (0<<WGM11)|(0<<WGM10);	//Configuración de comparador CTC; TCCR1B -> WMG13 = 0 y WMG12 = 1; TCCR1A -> WMG11 = 0 y WMG10 = 0; El timer T1 se maneja distinto.
 2e0:	8c 91       	ld	r24, X
 2e2:	8c 93       	st	X, r24
	TCCR2A |= (1<<WGM21)|(0<<WGM20);	//Configuración de comparador CTC; TCCR2B -> WMG02 = 0; TCCR2A -> WMG21 = 1 y WMG20 = 0
 2e4:	80 81       	ld	r24, Z
 2e6:	82 60       	ori	r24, 0x02	; 2
 2e8:	80 83       	st	Z, r24
	
	-	La instrucción &= lo que hace es solo asignar el valor de un bit 0 de un número binario sin afectar a los demás.
	-	La instrucción |= lo que hace es solo asignar el valor de un bit 1 de un número binario sin afectar a los demás.*/
	//TCCR#B o registro de control del temporizador: Sirve para indicar la configuración de escala y tipo de comparador.
	//ESCALA DEL TEMPORIZADOR:
	TCCR1B |= (1<<CS12)|(0<<CS11)|(0<<CS10);			//T1: Escala de 256;	CS12 = 1, CS11 = 0 y CS10 = 0
 2ea:	e1 e8       	ldi	r30, 0x81	; 129
 2ec:	f0 e0       	ldi	r31, 0x00	; 0
 2ee:	80 81       	ld	r24, Z
 2f0:	84 60       	ori	r24, 0x04	; 4
 2f2:	80 83       	st	Z, r24
	TCCR2B |= (1<<CS22)|(1<<CS21)|(1<<CS20)|(0<<WGM22);	//T2: Escala de 1024;	CS22 = 1, CS21 = 1 y CS20 = 1, no se puede usar un timer externo con T2, se maneja diferente.
 2f4:	a1 eb       	ldi	r26, 0xB1	; 177
 2f6:	b0 e0       	ldi	r27, 0x00	; 0
 2f8:	8c 91       	ld	r24, X
 2fa:	87 60       	ori	r24, 0x07	; 7
 2fc:	8c 93       	st	X, r24
	//TIPO DE COMPARADOR - PARTE 2/2:
	/*Aguas porque asignar ceros solos, normalmente causa problemas, si se quiere poner explícitamente, debe estar incluido dentro de una declaración con varios bits, en 
	específico se encuentra declarada en los registros TCCR#B de arriba, por eso en esta parte se comentó y solo se dejó indicado para que fuera más entendible.*/
	//TCCR0B &= (0<<WGM02);						//Configuración de comparador CTC; TCCR0B -> WMG02 = 0; TCCR0A -> WMG01 = 1 y WMG00 = 0
	TCCR1B |= (1<<WGM12)|(0<<WGM13);			//Configuración de comparador CTC; TCCR1B -> WMG13 = 0 y WMG12 = 1; TCCR1A -> WMG11 = 0 y WMG10 = 0; T1 se maneja distinto.
 2fe:	80 81       	ld	r24, Z
 300:	88 60       	ori	r24, 0x08	; 8
 302:	80 83       	st	Z, r24
		- TOIE0: Hace que el timer T0 de 8 bits sea de tipo desbordamiento si se le manda un 1 lógico y si se queda como 0 lógico es de tipo comparación.
		
		- OCIE2A: Hace que el timer T2 de 8 bits sea de tipo comparación y que se active el registro OCR0A para marcar el límite del conteo.
		- OCIE1A: Hace que el timer T1 de 16 bits sea de tipo comparación y que se active el registro OCR1A para marcar el límite del conteo.
		- OCIE0A: Hace que el timer T0 de 8 bits sea de tipo comparación y que se active el registro OCR2A para marcar el límite del conteo.*/
	TIMSK1 |= (0<<TOIE1)|(1<<OCIE1A); //Timer T1 de 16 bits habilitado como tipo comparación, registro de comparación OCR1A activado. Solo se puede usar el canal A en CTC.
 304:	ef e6       	ldi	r30, 0x6F	; 111
 306:	f0 e0       	ldi	r31, 0x00	; 0
 308:	80 81       	ld	r24, Z
 30a:	82 60       	ori	r24, 0x02	; 2
 30c:	80 83       	st	Z, r24
	TIMSK2 |= (0<<TOIE2)|(1<<OCIE2A); //Timer T2 de 8 bits habilitado como tipo comparación, registro de comparación OCR2A activado. Solo se puede usar el canal A en CTC.
 30e:	e0 e7       	ldi	r30, 0x70	; 112
 310:	f0 e0       	ldi	r31, 0x00	; 0
 312:	80 81       	ld	r24, Z
 314:	82 60       	ori	r24, 0x02	; 2
 316:	80 83       	st	Z, r24
		En este caso al hacer varias iteraciones con todas las escalas, se eligió la de 1:256 para alcanzar la frecuencia de 1Hz.
		1.- OCR#A = (16X10^6/(frecuencia*2*escala)) - 1 = (16X10^6/(1*2*256)) - 1 = 31,249
		conteo_total_temporizador T0 y T2	= 255		= OCR0A_max y OCR2A_max
		conteo_total_temporizador T1		= 65,536	= OCR1A_max
		En el registro comparador OCR0A se debe poner su conteo máximo que es de 255.*/
	OCR1A = limite_conteo; //frecuencia = 1Hz; t_deseado = 1s; escala = 256; conteo_OCR = 31,249
 318:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <limite_conteo>
 31c:	30 91 07 01 	lds	r19, 0x0107	; 0x800107 <limite_conteo+0x1>
 320:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 324:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	En el registro comparador OCR2A se debe poner su conteo máximo que es de 255, como en este caso es mayor a ese número se calcula el número de ciclos y se pone en el 
	registro OCR2A su valor máximo que es de 255:
		1.2.- ciclos = conteo_OCR#A/conteo_total_temporizador = 15,624/255 = 61.2705 = 62
		1.3.- conteo_OCR#A = 255
	En el registro comparador OCR2A se debe poner su conteo máximo que es de 255 y crear una variable que guarde el número de ciclos calculados para usarse en la ISR.*/
	OCR2A = 255; //frecuencia = 1Hz; t_deseado = 2s; escala = 1024; conteo_OCR = 255; ciclos = 62
 328:	90 93 b3 00 	sts	0x00B3, r25	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
	
	//GTCCR: Una vez configurados los timers, se debe poner como cero el registro que reinicia y sincroniza los timers, liberando así los timers.
	GTCCR = (0<<TSM)|(0<<PSRASY)|(0<<PSRSYNC); //TSM -> Timers NO sincronizados; PSRASY -> Timer T2 NO reiniciado; PSRSYNC -> Timers T0 y T1 NO reiniciados.
 32c:	13 bc       	out	0x23, r1	; 35
	
	/*SEI: Cuando se activa una SEI interruption, automáticamente el bit 7 del status register (GI) se convierte en 1 lógico, lo que convierte a las interrupciones en NMI 
	(No Mask Interruption):
		- Cuando GI tiene valor de 1 lógico no está activada ninguna interrupción, osea que es NMI, Non Maskable Interrupt.
		- Cuando GI tiene valor de 0 lógico está activada la interrupción, osea que es MI, Maskable Interrupt.*/
	sei(); //Permite cualquier interrupción que entre ya después de haber programado la máquina y cuando haya terminado de ejecutarse una interrupción anterior.
 32e:	78 94       	sei
	
	//EJECUCIÓN DEL PROGRAMA: Ya después de haber configurado las interrupciones es cuando se ejecuta la función del programa.
	//MANEJO DE LCD
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 330:	0e 94 94 00 	call	0x128	; 0x128 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 334:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <LIMPIA_LCD>
	//MENSAJE_INICIAL: Función normal para mostrar un mensaje inicial después o antes de que se haya presionado una interrupción.
	MENSAJE_INICIAL();
 338:	0e 94 04 01 	call	0x208	; 0x208 <MENSAJE_INICIAL>
			10.- frecuencia = fmicro/(2*escala*(1+OCR#A)) = (16X10^6)/(2*escala*(1+30)) = 1008.0645 Hz*/
    while (1){
		//MOSTRAR CONTEO EN LCD:
		/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de 
		cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
		POS_LINEA2(0);
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
		/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido 
		cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
		ENVIA_CADENA("de: ");
 342:	87 e1       	ldi	r24, 0x17	; 23
 344:	91 e0       	ldi	r25, 0x01	; 1
 346:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
		double:	Números fraccional con máximo 15 decimales después del punto, utilizan un espacio de memoria de 8 bytes. Su formato es el %lf.
		char:	Caracater, representa una sola letra o valor ASCII, utilizan un espacio de memoria de 1 byte. Su formato es el %s.
		Ya conocidos los formatos asociados a cada tipo primitivo, se usan dos variables y el formato del número que ingresa al método sprintf() que sirve para realizar la 
		conversión.*/
		//sprintf(variable_que_guarda_el_resultado, "formato_numero", numero_inicial): Método para convertir números a cadenas de caracteres.
		sprintf(f_string, "%d", f);
 34a:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <f+0x1>
 34e:	8f 93       	push	r24
 350:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <f>
 354:	8f 93       	push	r24
 356:	8c e1       	ldi	r24, 0x1C	; 28
 358:	91 e0       	ldi	r25, 0x01	; 1
 35a:	9f 93       	push	r25
 35c:	8f 93       	push	r24
 35e:	8a e2       	ldi	r24, 0x2A	; 42
 360:	91 e0       	ldi	r25, 0x01	; 1
 362:	9f 93       	push	r25
 364:	8f 93       	push	r24
 366:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <sprintf>
		ENVIA_CADENA(f_string);	//Impresión de la frecuencia de la señal, que aumenta o se reduce cada vez que se presiona el botón + o - del Puerto B.
 36a:	8a e2       	ldi	r24, 0x2A	; 42
 36c:	91 e0       	ldi	r25, 0x01	; 1
 36e:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
		/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido 
		cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
		ENVIA_CADENA(" Hz");
 372:	8f e1       	ldi	r24, 0x1F	; 31
 374:	91 e0       	ldi	r25, 0x01	; 1
 376:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
		
		/*ELECCIÓN DE FRECUENCIAS PARA IMPRIMIRSE EN EL LCD Y VALORES DEL REGISTRO OCR#A: A cada una de las opciones se le agregan espacios vacíos porque sino van apareciendo
		letras indeseables cuando cambia el largo del número que aparece en el LCD si es que no se pone en cierta posición el espacio vacío.*/
		switch (lista_frecuencias){
 37a:	0f 90       	pop	r0
 37c:	0f 90       	pop	r0
 37e:	0f 90       	pop	r0
 380:	0f 90       	pop	r0
 382:	0f 90       	pop	r0
 384:	0f 90       	pop	r0
 386:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <lista_frecuencias>
 38a:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <lista_frecuencias+0x1>
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	ea 30       	cpi	r30, 0x0A	; 10
 392:	f1 05       	cpc	r31, r1
 394:	08 f0       	brcs	.+2      	; 0x398 <main+0xf8>
 396:	c5 c0       	rjmp	.+394    	; 0x522 <__EEPROM_REGION_LENGTH__+0x122>
 398:	ec 5c       	subi	r30, 0xCC	; 204
 39a:	ff 4f       	sbci	r31, 0xFF	; 255
 39c:	0c 94 da 02 	jmp	0x5b4	; 0x5b4 <__tablejump2__>
			case 1:		//OCR#A = 31249;	frecuencia = 1 [Hz]
				f = 1.0;
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	90 e0       	ldi	r25, 0x00	; 0
 3a4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 3a8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 31249;
 3ac:	81 e1       	ldi	r24, 0x11	; 17
 3ae:	9a e7       	ldi	r25, 0x7A	; 122
 3b0:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 3b4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(8);
 3b8:	88 e0       	ldi	r24, 0x08	; 8
 3ba:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA("   ");
 3be:	83 e2       	ldi	r24, 0x23	; 35
 3c0:	91 e0       	ldi	r25, 0x01	; 1
 3c2:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 3c6:	ba cf       	rjmp	.-140    	; 0x33c <main+0x9c>
			case 2:		//OCR#A = 311;		frecuencia = 100.1602	[Hz]
				f = 100.1602;
 3c8:	84 e6       	ldi	r24, 0x64	; 100
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 3d0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 311;
 3d4:	87 e3       	ldi	r24, 0x37	; 55
 3d6:	91 e0       	ldi	r25, 0x01	; 1
 3d8:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 3dc:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 3e0:	8a e0       	ldi	r24, 0x0A	; 10
 3e2:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 3e6:	85 e2       	ldi	r24, 0x25	; 37
 3e8:	91 e0       	ldi	r25, 0x01	; 1
 3ea:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 3ee:	a6 cf       	rjmp	.-180    	; 0x33c <main+0x9c>
			case 3:		//OCR#A = 155;		frecuencia = 200.3205	[Hz]
				f = 200.3205;
 3f0:	88 ec       	ldi	r24, 0xC8	; 200
 3f2:	90 e0       	ldi	r25, 0x00	; 0
 3f4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 3f8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 155;
 3fc:	8b e9       	ldi	r24, 0x9B	; 155
 3fe:	90 e0       	ldi	r25, 0x00	; 0
 400:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 404:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 408:	8a e0       	ldi	r24, 0x0A	; 10
 40a:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 40e:	85 e2       	ldi	r24, 0x25	; 37
 410:	91 e0       	ldi	r25, 0x01	; 1
 412:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 416:	92 cf       	rjmp	.-220    	; 0x33c <main+0x9c>
			case 4:		//OCR#A = 103;		frecuencia = 300.4807	[Hz]
				f = 300.4807;
 418:	8c e2       	ldi	r24, 0x2C	; 44
 41a:	91 e0       	ldi	r25, 0x01	; 1
 41c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 420:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 103;
 424:	87 e6       	ldi	r24, 0x67	; 103
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 42c:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 430:	8a e0       	ldi	r24, 0x0A	; 10
 432:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 436:	85 e2       	ldi	r24, 0x25	; 37
 438:	91 e0       	ldi	r25, 0x01	; 1
 43a:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 43e:	7e cf       	rjmp	.-260    	; 0x33c <main+0x9c>
			case 5:		//OCR#A = 77;		frecuencia = 400.6410	[Hz]
				f = 400.6410;
 440:	80 e9       	ldi	r24, 0x90	; 144
 442:	91 e0       	ldi	r25, 0x01	; 1
 444:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 448:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 77;
 44c:	8d e4       	ldi	r24, 0x4D	; 77
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 454:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 458:	8a e0       	ldi	r24, 0x0A	; 10
 45a:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 45e:	85 e2       	ldi	r24, 0x25	; 37
 460:	91 e0       	ldi	r25, 0x01	; 1
 462:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 466:	6a cf       	rjmp	.-300    	; 0x33c <main+0x9c>
			case 6:		//OCR#A = 61;		frecuencia = 504.0322	[Hz]
				f = 504.0322;
 468:	88 ef       	ldi	r24, 0xF8	; 248
 46a:	91 e0       	ldi	r25, 0x01	; 1
 46c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 470:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 61;
 474:	8d e3       	ldi	r24, 0x3D	; 61
 476:	90 e0       	ldi	r25, 0x00	; 0
 478:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 47c:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 480:	8a e0       	ldi	r24, 0x0A	; 10
 482:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 486:	85 e2       	ldi	r24, 0x25	; 37
 488:	91 e0       	ldi	r25, 0x01	; 1
 48a:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 48e:	56 cf       	rjmp	.-340    	; 0x33c <main+0x9c>
			case 7:		//OCR#A = 51;		frecuencia = 600.9615	[Hz]
				f = 600.9615;
 490:	88 e5       	ldi	r24, 0x58	; 88
 492:	92 e0       	ldi	r25, 0x02	; 2
 494:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 498:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 51;
 49c:	83 e3       	ldi	r24, 0x33	; 51
 49e:	90 e0       	ldi	r25, 0x00	; 0
 4a0:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 4a4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 4a8:	8a e0       	ldi	r24, 0x0A	; 10
 4aa:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 4ae:	85 e2       	ldi	r24, 0x25	; 37
 4b0:	91 e0       	ldi	r25, 0x01	; 1
 4b2:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 4b6:	42 cf       	rjmp	.-380    	; 0x33c <main+0x9c>
			case 8:		//OCR#A = 43;		frecuencia = 710.2272	[Hz]
				f = 710.2272;
 4b8:	86 ec       	ldi	r24, 0xC6	; 198
 4ba:	92 e0       	ldi	r25, 0x02	; 2
 4bc:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 4c0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 43;
 4c4:	8b e2       	ldi	r24, 0x2B	; 43
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 4cc:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 4d0:	8a e0       	ldi	r24, 0x0A	; 10
 4d2:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 4d6:	85 e2       	ldi	r24, 0x25	; 37
 4d8:	91 e0       	ldi	r25, 0x01	; 1
 4da:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 4de:	2e cf       	rjmp	.-420    	; 0x33c <main+0x9c>
			case 9:		//OCR#A = 31;		frecuencia = 976.5625	[Hz]
				f = 976.5625;
 4e0:	80 ed       	ldi	r24, 0xD0	; 208
 4e2:	93 e0       	ldi	r25, 0x03	; 3
 4e4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 4e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 31;
 4ec:	8f e1       	ldi	r24, 0x1F	; 31
 4ee:	90 e0       	ldi	r25, 0x00	; 0
 4f0:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 4f4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica 
				después de cual de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
				POS_LINEA2(10);
 4f8:	8a e0       	ldi	r24, 0x0A	; 10
 4fa:	0e 94 00 01 	call	0x200	; 0x200 <POS_LINEA2>
				/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya 
				recorrido cada letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos 
				para que quepan.*/
				ENVIA_CADENA(" ");
 4fe:	85 e2       	ldi	r24, 0x25	; 37
 500:	91 e0       	ldi	r25, 0x01	; 1
 502:	0e 94 de 00 	call	0x1bc	; 0x1bc <ENVIA_CADENA>
				break;
 506:	1a cf       	rjmp	.-460    	; 0x33c <main+0x9c>
			case 10:	//OCR#A = 30;		frecuencia = 1008.0645	[Hz]
				f = 1008.0645;
 508:	80 ef       	ldi	r24, 0xF0	; 240
 50a:	93 e0       	ldi	r25, 0x03	; 3
 50c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 510:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 30;
 514:	8e e1       	ldi	r24, 0x1E	; 30
 516:	90 e0       	ldi	r25, 0x00	; 0
 518:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 51c:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				break;
 520:	0d cf       	rjmp	.-486    	; 0x33c <main+0x9c>
			default:
				f = 1.0;
 522:	81 e0       	ldi	r24, 0x01	; 1
 524:	90 e0       	ldi	r25, 0x00	; 0
 526:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <f+0x1>
 52a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <f>
				limite_conteo = 31249;
 52e:	81 e1       	ldi	r24, 0x11	; 17
 530:	9a e7       	ldi	r25, 0x7A	; 122
 532:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <limite_conteo+0x1>
 536:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <limite_conteo>
				break;
 53a:	00 cf       	rjmp	.-512    	; 0x33c <main+0x9c>

0000053c <__vector_11>:



//Funciones ISR: Tareas ejecutadas por las interrupciones externas causadas por temporizadores.
//ISR T1 - 1s: Recibe como parámetro el vector TIMER1_COMPA_vect porque la interrupción es activada por la comparación con el registro OCR1A y TCNT1 del timer T1.
ISR (TIMER1_COMPA_vect){
 53c:	1f 92       	push	r1
 53e:	0f 92       	push	r0
 540:	0f b6       	in	r0, 0x3f	; 63
 542:	0f 92       	push	r0
 544:	11 24       	eor	r1, r1
 546:	8f 93       	push	r24
 548:	9f 93       	push	r25
	Nadamás se deja la acción que se quiere ejecutar cuando se alcance el valor máximo del conteo marcado por OCR#A.*/
	
	/*PARPADEO DEL LED: Cuando existan ciclos en la operación del contador, se debe usar una variable global que cuente el número de ciclos cada vez que se ejecute una 
	interrupción y al llegar al número de ciclos calculados, haga el parpadeo y a su vez regrese el valor de la variable global a cero.*/
	//MÁSCARA XOR: Deja pasar tal cual todo lo que esté en contacto con los 0 de la máscara e invierte todo lo que esté en contacto con los 1 de la máscara.
	PORTB ^= (1<<PORTB0);			//Con esta instrucción se invierte lo que haya en el pin PB0 cada que ocurra una interrupción causada por el temporizador T0.
 54a:	95 b1       	in	r25, 0x05	; 5
 54c:	81 e0       	ldi	r24, 0x01	; 1
 54e:	89 27       	eor	r24, r25
 550:	85 b9       	out	0x05, r24	; 5
}
 552:	9f 91       	pop	r25
 554:	8f 91       	pop	r24
 556:	0f 90       	pop	r0
 558:	0f be       	out	0x3f, r0	; 63
 55a:	0f 90       	pop	r0
 55c:	1f 90       	pop	r1
 55e:	18 95       	reti

00000560 <__vector_7>:

//ISR T2 - 2s: Recibe como parámetro el vector TIMER2_COMPA_vect porque la interrupción es activada por la comparación con el registro OCR2A y TCNT2 del timer T2.
ISR (TIMER2_COMPA_vect){
 560:	1f 92       	push	r1
 562:	0f 92       	push	r0
 564:	0f b6       	in	r0, 0x3f	; 63
 566:	0f 92       	push	r0
 568:	11 24       	eor	r1, r1
 56a:	2f 93       	push	r18
 56c:	3f 93       	push	r19
 56e:	8f 93       	push	r24
 570:	9f 93       	push	r25
	Nadamás se deja la acción que se quiere ejecutar cuando se alcance el valor máximo del conteo marcado por OCR#A, sino se debe calcular el número de ciclos y crear un 
	condicional if.*/
	
	/*PARPADEO DEL LED: Cuando existan ciclos en la operación del contador, se debe usar una variable global que cuente el número de ciclos cada vez que se ejecute una 
	interrupción y al llegar al número de ciclos calculados, haga el parpadeo y a su vez regrese el valor de la variable global a cero.*/
	cliclos_transcurridos_t2++; //Aumento de la variable que almacena el número de ciclos cada vez que se ejecuta una interrupción por el desborde del temporizador.
 572:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <__data_end>
 576:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <__data_end+0x1>
 57a:	01 96       	adiw	r24, 0x01	; 1
 57c:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__data_end+0x1>
 580:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__data_end>
	
	if(cliclos_transcurridos_t2 >= cliclos_t2){
 584:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 588:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 58c:	82 17       	cp	r24, r18
 58e:	93 07       	cpc	r25, r19
 590:	44 f0       	brlt	.+16     	; 0x5a2 <__vector_7+0x42>
		//MÁSCARA XOR (^=): Deja pasar tal cual todo lo que esté en contacto con los 0 de la máscara e invierte todo lo que esté en contacto con los 1 de la máscara.
		PORTD ^= (1<<PORTD0);			//Con esta instrucción se invierte lo que haya en el pin PC0 cada que ocurra una interrupción causada por el temporizador T2.
 592:	9b b1       	in	r25, 0x0b	; 11
 594:	81 e0       	ldi	r24, 0x01	; 1
 596:	89 27       	eor	r24, r25
 598:	8b b9       	out	0x0b, r24	; 11
		cliclos_transcurridos_t2 = 0;	//Reinicio de la variable que almacena el número de ciclos transcurridos.
 59a:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__data_end+0x1>
 59e:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__data_end>
	}
 5a2:	9f 91       	pop	r25
 5a4:	8f 91       	pop	r24
 5a6:	3f 91       	pop	r19
 5a8:	2f 91       	pop	r18
 5aa:	0f 90       	pop	r0
 5ac:	0f be       	out	0x3f, r0	; 63
 5ae:	0f 90       	pop	r0
 5b0:	1f 90       	pop	r1
 5b2:	18 95       	reti

000005b4 <__tablejump2__>:
 5b4:	ee 0f       	add	r30, r30
 5b6:	ff 1f       	adc	r31, r31
 5b8:	05 90       	lpm	r0, Z+
 5ba:	f4 91       	lpm	r31, Z
 5bc:	e0 2d       	mov	r30, r0
 5be:	09 94       	ijmp

000005c0 <sprintf>:
 5c0:	ae e0       	ldi	r26, 0x0E	; 14
 5c2:	b0 e0       	ldi	r27, 0x00	; 0
 5c4:	e6 ee       	ldi	r30, 0xE6	; 230
 5c6:	f2 e0       	ldi	r31, 0x02	; 2
 5c8:	0c 94 a1 05 	jmp	0xb42	; 0xb42 <__prologue_saves__+0x1c>
 5cc:	0d 89       	ldd	r16, Y+21	; 0x15
 5ce:	1e 89       	ldd	r17, Y+22	; 0x16
 5d0:	86 e0       	ldi	r24, 0x06	; 6
 5d2:	8c 83       	std	Y+4, r24	; 0x04
 5d4:	1a 83       	std	Y+2, r17	; 0x02
 5d6:	09 83       	std	Y+1, r16	; 0x01
 5d8:	8f ef       	ldi	r24, 0xFF	; 255
 5da:	9f e7       	ldi	r25, 0x7F	; 127
 5dc:	9e 83       	std	Y+6, r25	; 0x06
 5de:	8d 83       	std	Y+5, r24	; 0x05
 5e0:	ae 01       	movw	r20, r28
 5e2:	47 5e       	subi	r20, 0xE7	; 231
 5e4:	5f 4f       	sbci	r21, 0xFF	; 255
 5e6:	6f 89       	ldd	r22, Y+23	; 0x17
 5e8:	78 8d       	ldd	r23, Y+24	; 0x18
 5ea:	ce 01       	movw	r24, r28
 5ec:	01 96       	adiw	r24, 0x01	; 1
 5ee:	0e 94 02 03 	call	0x604	; 0x604 <vfprintf>
 5f2:	ef 81       	ldd	r30, Y+7	; 0x07
 5f4:	f8 85       	ldd	r31, Y+8	; 0x08
 5f6:	e0 0f       	add	r30, r16
 5f8:	f1 1f       	adc	r31, r17
 5fa:	10 82       	st	Z, r1
 5fc:	2e 96       	adiw	r28, 0x0e	; 14
 5fe:	e4 e0       	ldi	r30, 0x04	; 4
 600:	0c 94 bd 05 	jmp	0xb7a	; 0xb7a <__epilogue_restores__+0x1c>

00000604 <vfprintf>:
 604:	ab e0       	ldi	r26, 0x0B	; 11
 606:	b0 e0       	ldi	r27, 0x00	; 0
 608:	e8 e0       	ldi	r30, 0x08	; 8
 60a:	f3 e0       	ldi	r31, 0x03	; 3
 60c:	0c 94 93 05 	jmp	0xb26	; 0xb26 <__prologue_saves__>
 610:	6c 01       	movw	r12, r24
 612:	7b 01       	movw	r14, r22
 614:	8a 01       	movw	r16, r20
 616:	fc 01       	movw	r30, r24
 618:	17 82       	std	Z+7, r1	; 0x07
 61a:	16 82       	std	Z+6, r1	; 0x06
 61c:	83 81       	ldd	r24, Z+3	; 0x03
 61e:	81 ff       	sbrs	r24, 1
 620:	cc c1       	rjmp	.+920    	; 0x9ba <__stack+0xbb>
 622:	ce 01       	movw	r24, r28
 624:	01 96       	adiw	r24, 0x01	; 1
 626:	3c 01       	movw	r6, r24
 628:	f6 01       	movw	r30, r12
 62a:	93 81       	ldd	r25, Z+3	; 0x03
 62c:	f7 01       	movw	r30, r14
 62e:	93 fd       	sbrc	r25, 3
 630:	85 91       	lpm	r24, Z+
 632:	93 ff       	sbrs	r25, 3
 634:	81 91       	ld	r24, Z+
 636:	7f 01       	movw	r14, r30
 638:	88 23       	and	r24, r24
 63a:	09 f4       	brne	.+2      	; 0x63e <vfprintf+0x3a>
 63c:	ba c1       	rjmp	.+884    	; 0x9b2 <__stack+0xb3>
 63e:	85 32       	cpi	r24, 0x25	; 37
 640:	39 f4       	brne	.+14     	; 0x650 <vfprintf+0x4c>
 642:	93 fd       	sbrc	r25, 3
 644:	85 91       	lpm	r24, Z+
 646:	93 ff       	sbrs	r25, 3
 648:	81 91       	ld	r24, Z+
 64a:	7f 01       	movw	r14, r30
 64c:	85 32       	cpi	r24, 0x25	; 37
 64e:	29 f4       	brne	.+10     	; 0x65a <vfprintf+0x56>
 650:	b6 01       	movw	r22, r12
 652:	90 e0       	ldi	r25, 0x00	; 0
 654:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 658:	e7 cf       	rjmp	.-50     	; 0x628 <vfprintf+0x24>
 65a:	91 2c       	mov	r9, r1
 65c:	21 2c       	mov	r2, r1
 65e:	31 2c       	mov	r3, r1
 660:	ff e1       	ldi	r31, 0x1F	; 31
 662:	f3 15       	cp	r31, r3
 664:	d8 f0       	brcs	.+54     	; 0x69c <vfprintf+0x98>
 666:	8b 32       	cpi	r24, 0x2B	; 43
 668:	79 f0       	breq	.+30     	; 0x688 <vfprintf+0x84>
 66a:	38 f4       	brcc	.+14     	; 0x67a <vfprintf+0x76>
 66c:	80 32       	cpi	r24, 0x20	; 32
 66e:	79 f0       	breq	.+30     	; 0x68e <vfprintf+0x8a>
 670:	83 32       	cpi	r24, 0x23	; 35
 672:	a1 f4       	brne	.+40     	; 0x69c <vfprintf+0x98>
 674:	23 2d       	mov	r18, r3
 676:	20 61       	ori	r18, 0x10	; 16
 678:	1d c0       	rjmp	.+58     	; 0x6b4 <vfprintf+0xb0>
 67a:	8d 32       	cpi	r24, 0x2D	; 45
 67c:	61 f0       	breq	.+24     	; 0x696 <vfprintf+0x92>
 67e:	80 33       	cpi	r24, 0x30	; 48
 680:	69 f4       	brne	.+26     	; 0x69c <vfprintf+0x98>
 682:	23 2d       	mov	r18, r3
 684:	21 60       	ori	r18, 0x01	; 1
 686:	16 c0       	rjmp	.+44     	; 0x6b4 <vfprintf+0xb0>
 688:	83 2d       	mov	r24, r3
 68a:	82 60       	ori	r24, 0x02	; 2
 68c:	38 2e       	mov	r3, r24
 68e:	e3 2d       	mov	r30, r3
 690:	e4 60       	ori	r30, 0x04	; 4
 692:	3e 2e       	mov	r3, r30
 694:	2a c0       	rjmp	.+84     	; 0x6ea <vfprintf+0xe6>
 696:	f3 2d       	mov	r31, r3
 698:	f8 60       	ori	r31, 0x08	; 8
 69a:	1d c0       	rjmp	.+58     	; 0x6d6 <vfprintf+0xd2>
 69c:	37 fc       	sbrc	r3, 7
 69e:	2d c0       	rjmp	.+90     	; 0x6fa <vfprintf+0xf6>
 6a0:	20 ed       	ldi	r18, 0xD0	; 208
 6a2:	28 0f       	add	r18, r24
 6a4:	2a 30       	cpi	r18, 0x0A	; 10
 6a6:	40 f0       	brcs	.+16     	; 0x6b8 <vfprintf+0xb4>
 6a8:	8e 32       	cpi	r24, 0x2E	; 46
 6aa:	b9 f4       	brne	.+46     	; 0x6da <vfprintf+0xd6>
 6ac:	36 fc       	sbrc	r3, 6
 6ae:	81 c1       	rjmp	.+770    	; 0x9b2 <__stack+0xb3>
 6b0:	23 2d       	mov	r18, r3
 6b2:	20 64       	ori	r18, 0x40	; 64
 6b4:	32 2e       	mov	r3, r18
 6b6:	19 c0       	rjmp	.+50     	; 0x6ea <vfprintf+0xe6>
 6b8:	36 fe       	sbrs	r3, 6
 6ba:	06 c0       	rjmp	.+12     	; 0x6c8 <vfprintf+0xc4>
 6bc:	8a e0       	ldi	r24, 0x0A	; 10
 6be:	98 9e       	mul	r9, r24
 6c0:	20 0d       	add	r18, r0
 6c2:	11 24       	eor	r1, r1
 6c4:	92 2e       	mov	r9, r18
 6c6:	11 c0       	rjmp	.+34     	; 0x6ea <vfprintf+0xe6>
 6c8:	ea e0       	ldi	r30, 0x0A	; 10
 6ca:	2e 9e       	mul	r2, r30
 6cc:	20 0d       	add	r18, r0
 6ce:	11 24       	eor	r1, r1
 6d0:	22 2e       	mov	r2, r18
 6d2:	f3 2d       	mov	r31, r3
 6d4:	f0 62       	ori	r31, 0x20	; 32
 6d6:	3f 2e       	mov	r3, r31
 6d8:	08 c0       	rjmp	.+16     	; 0x6ea <vfprintf+0xe6>
 6da:	8c 36       	cpi	r24, 0x6C	; 108
 6dc:	21 f4       	brne	.+8      	; 0x6e6 <vfprintf+0xe2>
 6de:	83 2d       	mov	r24, r3
 6e0:	80 68       	ori	r24, 0x80	; 128
 6e2:	38 2e       	mov	r3, r24
 6e4:	02 c0       	rjmp	.+4      	; 0x6ea <vfprintf+0xe6>
 6e6:	88 36       	cpi	r24, 0x68	; 104
 6e8:	41 f4       	brne	.+16     	; 0x6fa <vfprintf+0xf6>
 6ea:	f7 01       	movw	r30, r14
 6ec:	93 fd       	sbrc	r25, 3
 6ee:	85 91       	lpm	r24, Z+
 6f0:	93 ff       	sbrs	r25, 3
 6f2:	81 91       	ld	r24, Z+
 6f4:	7f 01       	movw	r14, r30
 6f6:	81 11       	cpse	r24, r1
 6f8:	b3 cf       	rjmp	.-154    	; 0x660 <vfprintf+0x5c>
 6fa:	98 2f       	mov	r25, r24
 6fc:	9f 7d       	andi	r25, 0xDF	; 223
 6fe:	95 54       	subi	r25, 0x45	; 69
 700:	93 30       	cpi	r25, 0x03	; 3
 702:	28 f4       	brcc	.+10     	; 0x70e <vfprintf+0x10a>
 704:	0c 5f       	subi	r16, 0xFC	; 252
 706:	1f 4f       	sbci	r17, 0xFF	; 255
 708:	9f e3       	ldi	r25, 0x3F	; 63
 70a:	99 83       	std	Y+1, r25	; 0x01
 70c:	0d c0       	rjmp	.+26     	; 0x728 <vfprintf+0x124>
 70e:	83 36       	cpi	r24, 0x63	; 99
 710:	31 f0       	breq	.+12     	; 0x71e <vfprintf+0x11a>
 712:	83 37       	cpi	r24, 0x73	; 115
 714:	71 f0       	breq	.+28     	; 0x732 <vfprintf+0x12e>
 716:	83 35       	cpi	r24, 0x53	; 83
 718:	09 f0       	breq	.+2      	; 0x71c <vfprintf+0x118>
 71a:	59 c0       	rjmp	.+178    	; 0x7ce <vfprintf+0x1ca>
 71c:	21 c0       	rjmp	.+66     	; 0x760 <vfprintf+0x15c>
 71e:	f8 01       	movw	r30, r16
 720:	80 81       	ld	r24, Z
 722:	89 83       	std	Y+1, r24	; 0x01
 724:	0e 5f       	subi	r16, 0xFE	; 254
 726:	1f 4f       	sbci	r17, 0xFF	; 255
 728:	88 24       	eor	r8, r8
 72a:	83 94       	inc	r8
 72c:	91 2c       	mov	r9, r1
 72e:	53 01       	movw	r10, r6
 730:	13 c0       	rjmp	.+38     	; 0x758 <vfprintf+0x154>
 732:	28 01       	movw	r4, r16
 734:	f2 e0       	ldi	r31, 0x02	; 2
 736:	4f 0e       	add	r4, r31
 738:	51 1c       	adc	r5, r1
 73a:	f8 01       	movw	r30, r16
 73c:	a0 80       	ld	r10, Z
 73e:	b1 80       	ldd	r11, Z+1	; 0x01
 740:	36 fe       	sbrs	r3, 6
 742:	03 c0       	rjmp	.+6      	; 0x74a <vfprintf+0x146>
 744:	69 2d       	mov	r22, r9
 746:	70 e0       	ldi	r23, 0x00	; 0
 748:	02 c0       	rjmp	.+4      	; 0x74e <vfprintf+0x14a>
 74a:	6f ef       	ldi	r22, 0xFF	; 255
 74c:	7f ef       	ldi	r23, 0xFF	; 255
 74e:	c5 01       	movw	r24, r10
 750:	0e 94 ee 04 	call	0x9dc	; 0x9dc <strnlen>
 754:	4c 01       	movw	r8, r24
 756:	82 01       	movw	r16, r4
 758:	f3 2d       	mov	r31, r3
 75a:	ff 77       	andi	r31, 0x7F	; 127
 75c:	3f 2e       	mov	r3, r31
 75e:	16 c0       	rjmp	.+44     	; 0x78c <vfprintf+0x188>
 760:	28 01       	movw	r4, r16
 762:	22 e0       	ldi	r18, 0x02	; 2
 764:	42 0e       	add	r4, r18
 766:	51 1c       	adc	r5, r1
 768:	f8 01       	movw	r30, r16
 76a:	a0 80       	ld	r10, Z
 76c:	b1 80       	ldd	r11, Z+1	; 0x01
 76e:	36 fe       	sbrs	r3, 6
 770:	03 c0       	rjmp	.+6      	; 0x778 <vfprintf+0x174>
 772:	69 2d       	mov	r22, r9
 774:	70 e0       	ldi	r23, 0x00	; 0
 776:	02 c0       	rjmp	.+4      	; 0x77c <vfprintf+0x178>
 778:	6f ef       	ldi	r22, 0xFF	; 255
 77a:	7f ef       	ldi	r23, 0xFF	; 255
 77c:	c5 01       	movw	r24, r10
 77e:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <strnlen_P>
 782:	4c 01       	movw	r8, r24
 784:	f3 2d       	mov	r31, r3
 786:	f0 68       	ori	r31, 0x80	; 128
 788:	3f 2e       	mov	r3, r31
 78a:	82 01       	movw	r16, r4
 78c:	33 fc       	sbrc	r3, 3
 78e:	1b c0       	rjmp	.+54     	; 0x7c6 <vfprintf+0x1c2>
 790:	82 2d       	mov	r24, r2
 792:	90 e0       	ldi	r25, 0x00	; 0
 794:	88 16       	cp	r8, r24
 796:	99 06       	cpc	r9, r25
 798:	b0 f4       	brcc	.+44     	; 0x7c6 <vfprintf+0x1c2>
 79a:	b6 01       	movw	r22, r12
 79c:	80 e2       	ldi	r24, 0x20	; 32
 79e:	90 e0       	ldi	r25, 0x00	; 0
 7a0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 7a4:	2a 94       	dec	r2
 7a6:	f4 cf       	rjmp	.-24     	; 0x790 <vfprintf+0x18c>
 7a8:	f5 01       	movw	r30, r10
 7aa:	37 fc       	sbrc	r3, 7
 7ac:	85 91       	lpm	r24, Z+
 7ae:	37 fe       	sbrs	r3, 7
 7b0:	81 91       	ld	r24, Z+
 7b2:	5f 01       	movw	r10, r30
 7b4:	b6 01       	movw	r22, r12
 7b6:	90 e0       	ldi	r25, 0x00	; 0
 7b8:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 7bc:	21 10       	cpse	r2, r1
 7be:	2a 94       	dec	r2
 7c0:	21 e0       	ldi	r18, 0x01	; 1
 7c2:	82 1a       	sub	r8, r18
 7c4:	91 08       	sbc	r9, r1
 7c6:	81 14       	cp	r8, r1
 7c8:	91 04       	cpc	r9, r1
 7ca:	71 f7       	brne	.-36     	; 0x7a8 <vfprintf+0x1a4>
 7cc:	e8 c0       	rjmp	.+464    	; 0x99e <__stack+0x9f>
 7ce:	84 36       	cpi	r24, 0x64	; 100
 7d0:	11 f0       	breq	.+4      	; 0x7d6 <vfprintf+0x1d2>
 7d2:	89 36       	cpi	r24, 0x69	; 105
 7d4:	41 f5       	brne	.+80     	; 0x826 <__DATA_REGION_LENGTH__+0x26>
 7d6:	f8 01       	movw	r30, r16
 7d8:	37 fe       	sbrs	r3, 7
 7da:	07 c0       	rjmp	.+14     	; 0x7ea <vfprintf+0x1e6>
 7dc:	60 81       	ld	r22, Z
 7de:	71 81       	ldd	r23, Z+1	; 0x01
 7e0:	82 81       	ldd	r24, Z+2	; 0x02
 7e2:	93 81       	ldd	r25, Z+3	; 0x03
 7e4:	0c 5f       	subi	r16, 0xFC	; 252
 7e6:	1f 4f       	sbci	r17, 0xFF	; 255
 7e8:	08 c0       	rjmp	.+16     	; 0x7fa <vfprintf+0x1f6>
 7ea:	60 81       	ld	r22, Z
 7ec:	71 81       	ldd	r23, Z+1	; 0x01
 7ee:	07 2e       	mov	r0, r23
 7f0:	00 0c       	add	r0, r0
 7f2:	88 0b       	sbc	r24, r24
 7f4:	99 0b       	sbc	r25, r25
 7f6:	0e 5f       	subi	r16, 0xFE	; 254
 7f8:	1f 4f       	sbci	r17, 0xFF	; 255
 7fa:	f3 2d       	mov	r31, r3
 7fc:	ff 76       	andi	r31, 0x6F	; 111
 7fe:	3f 2e       	mov	r3, r31
 800:	97 ff       	sbrs	r25, 7
 802:	09 c0       	rjmp	.+18     	; 0x816 <__DATA_REGION_LENGTH__+0x16>
 804:	90 95       	com	r25
 806:	80 95       	com	r24
 808:	70 95       	com	r23
 80a:	61 95       	neg	r22
 80c:	7f 4f       	sbci	r23, 0xFF	; 255
 80e:	8f 4f       	sbci	r24, 0xFF	; 255
 810:	9f 4f       	sbci	r25, 0xFF	; 255
 812:	f0 68       	ori	r31, 0x80	; 128
 814:	3f 2e       	mov	r3, r31
 816:	2a e0       	ldi	r18, 0x0A	; 10
 818:	30 e0       	ldi	r19, 0x00	; 0
 81a:	a3 01       	movw	r20, r6
 81c:	0e 94 35 05 	call	0xa6a	; 0xa6a <__ultoa_invert>
 820:	88 2e       	mov	r8, r24
 822:	86 18       	sub	r8, r6
 824:	45 c0       	rjmp	.+138    	; 0x8b0 <__DATA_REGION_LENGTH__+0xb0>
 826:	85 37       	cpi	r24, 0x75	; 117
 828:	31 f4       	brne	.+12     	; 0x836 <__DATA_REGION_LENGTH__+0x36>
 82a:	23 2d       	mov	r18, r3
 82c:	2f 7e       	andi	r18, 0xEF	; 239
 82e:	b2 2e       	mov	r11, r18
 830:	2a e0       	ldi	r18, 0x0A	; 10
 832:	30 e0       	ldi	r19, 0x00	; 0
 834:	25 c0       	rjmp	.+74     	; 0x880 <__DATA_REGION_LENGTH__+0x80>
 836:	93 2d       	mov	r25, r3
 838:	99 7f       	andi	r25, 0xF9	; 249
 83a:	b9 2e       	mov	r11, r25
 83c:	8f 36       	cpi	r24, 0x6F	; 111
 83e:	c1 f0       	breq	.+48     	; 0x870 <__DATA_REGION_LENGTH__+0x70>
 840:	18 f4       	brcc	.+6      	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 842:	88 35       	cpi	r24, 0x58	; 88
 844:	79 f0       	breq	.+30     	; 0x864 <__DATA_REGION_LENGTH__+0x64>
 846:	b5 c0       	rjmp	.+362    	; 0x9b2 <__stack+0xb3>
 848:	80 37       	cpi	r24, 0x70	; 112
 84a:	19 f0       	breq	.+6      	; 0x852 <__DATA_REGION_LENGTH__+0x52>
 84c:	88 37       	cpi	r24, 0x78	; 120
 84e:	21 f0       	breq	.+8      	; 0x858 <__DATA_REGION_LENGTH__+0x58>
 850:	b0 c0       	rjmp	.+352    	; 0x9b2 <__stack+0xb3>
 852:	e9 2f       	mov	r30, r25
 854:	e0 61       	ori	r30, 0x10	; 16
 856:	be 2e       	mov	r11, r30
 858:	b4 fe       	sbrs	r11, 4
 85a:	0d c0       	rjmp	.+26     	; 0x876 <__DATA_REGION_LENGTH__+0x76>
 85c:	fb 2d       	mov	r31, r11
 85e:	f4 60       	ori	r31, 0x04	; 4
 860:	bf 2e       	mov	r11, r31
 862:	09 c0       	rjmp	.+18     	; 0x876 <__DATA_REGION_LENGTH__+0x76>
 864:	34 fe       	sbrs	r3, 4
 866:	0a c0       	rjmp	.+20     	; 0x87c <__DATA_REGION_LENGTH__+0x7c>
 868:	29 2f       	mov	r18, r25
 86a:	26 60       	ori	r18, 0x06	; 6
 86c:	b2 2e       	mov	r11, r18
 86e:	06 c0       	rjmp	.+12     	; 0x87c <__DATA_REGION_LENGTH__+0x7c>
 870:	28 e0       	ldi	r18, 0x08	; 8
 872:	30 e0       	ldi	r19, 0x00	; 0
 874:	05 c0       	rjmp	.+10     	; 0x880 <__DATA_REGION_LENGTH__+0x80>
 876:	20 e1       	ldi	r18, 0x10	; 16
 878:	30 e0       	ldi	r19, 0x00	; 0
 87a:	02 c0       	rjmp	.+4      	; 0x880 <__DATA_REGION_LENGTH__+0x80>
 87c:	20 e1       	ldi	r18, 0x10	; 16
 87e:	32 e0       	ldi	r19, 0x02	; 2
 880:	f8 01       	movw	r30, r16
 882:	b7 fe       	sbrs	r11, 7
 884:	07 c0       	rjmp	.+14     	; 0x894 <__DATA_REGION_LENGTH__+0x94>
 886:	60 81       	ld	r22, Z
 888:	71 81       	ldd	r23, Z+1	; 0x01
 88a:	82 81       	ldd	r24, Z+2	; 0x02
 88c:	93 81       	ldd	r25, Z+3	; 0x03
 88e:	0c 5f       	subi	r16, 0xFC	; 252
 890:	1f 4f       	sbci	r17, 0xFF	; 255
 892:	06 c0       	rjmp	.+12     	; 0x8a0 <__DATA_REGION_LENGTH__+0xa0>
 894:	60 81       	ld	r22, Z
 896:	71 81       	ldd	r23, Z+1	; 0x01
 898:	80 e0       	ldi	r24, 0x00	; 0
 89a:	90 e0       	ldi	r25, 0x00	; 0
 89c:	0e 5f       	subi	r16, 0xFE	; 254
 89e:	1f 4f       	sbci	r17, 0xFF	; 255
 8a0:	a3 01       	movw	r20, r6
 8a2:	0e 94 35 05 	call	0xa6a	; 0xa6a <__ultoa_invert>
 8a6:	88 2e       	mov	r8, r24
 8a8:	86 18       	sub	r8, r6
 8aa:	fb 2d       	mov	r31, r11
 8ac:	ff 77       	andi	r31, 0x7F	; 127
 8ae:	3f 2e       	mov	r3, r31
 8b0:	36 fe       	sbrs	r3, 6
 8b2:	0d c0       	rjmp	.+26     	; 0x8ce <__DATA_REGION_LENGTH__+0xce>
 8b4:	23 2d       	mov	r18, r3
 8b6:	2e 7f       	andi	r18, 0xFE	; 254
 8b8:	a2 2e       	mov	r10, r18
 8ba:	89 14       	cp	r8, r9
 8bc:	58 f4       	brcc	.+22     	; 0x8d4 <__DATA_REGION_LENGTH__+0xd4>
 8be:	34 fe       	sbrs	r3, 4
 8c0:	0b c0       	rjmp	.+22     	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
 8c2:	32 fc       	sbrc	r3, 2
 8c4:	09 c0       	rjmp	.+18     	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
 8c6:	83 2d       	mov	r24, r3
 8c8:	8e 7e       	andi	r24, 0xEE	; 238
 8ca:	a8 2e       	mov	r10, r24
 8cc:	05 c0       	rjmp	.+10     	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
 8ce:	b8 2c       	mov	r11, r8
 8d0:	a3 2c       	mov	r10, r3
 8d2:	03 c0       	rjmp	.+6      	; 0x8da <__DATA_REGION_LENGTH__+0xda>
 8d4:	b8 2c       	mov	r11, r8
 8d6:	01 c0       	rjmp	.+2      	; 0x8da <__DATA_REGION_LENGTH__+0xda>
 8d8:	b9 2c       	mov	r11, r9
 8da:	a4 fe       	sbrs	r10, 4
 8dc:	0f c0       	rjmp	.+30     	; 0x8fc <__DATA_REGION_LENGTH__+0xfc>
 8de:	fe 01       	movw	r30, r28
 8e0:	e8 0d       	add	r30, r8
 8e2:	f1 1d       	adc	r31, r1
 8e4:	80 81       	ld	r24, Z
 8e6:	80 33       	cpi	r24, 0x30	; 48
 8e8:	21 f4       	brne	.+8      	; 0x8f2 <__DATA_REGION_LENGTH__+0xf2>
 8ea:	9a 2d       	mov	r25, r10
 8ec:	99 7e       	andi	r25, 0xE9	; 233
 8ee:	a9 2e       	mov	r10, r25
 8f0:	09 c0       	rjmp	.+18     	; 0x904 <__stack+0x5>
 8f2:	a2 fe       	sbrs	r10, 2
 8f4:	06 c0       	rjmp	.+12     	; 0x902 <__stack+0x3>
 8f6:	b3 94       	inc	r11
 8f8:	b3 94       	inc	r11
 8fa:	04 c0       	rjmp	.+8      	; 0x904 <__stack+0x5>
 8fc:	8a 2d       	mov	r24, r10
 8fe:	86 78       	andi	r24, 0x86	; 134
 900:	09 f0       	breq	.+2      	; 0x904 <__stack+0x5>
 902:	b3 94       	inc	r11
 904:	a3 fc       	sbrc	r10, 3
 906:	11 c0       	rjmp	.+34     	; 0x92a <__stack+0x2b>
 908:	a0 fe       	sbrs	r10, 0
 90a:	06 c0       	rjmp	.+12     	; 0x918 <__stack+0x19>
 90c:	b2 14       	cp	r11, r2
 90e:	88 f4       	brcc	.+34     	; 0x932 <__stack+0x33>
 910:	28 0c       	add	r2, r8
 912:	92 2c       	mov	r9, r2
 914:	9b 18       	sub	r9, r11
 916:	0e c0       	rjmp	.+28     	; 0x934 <__stack+0x35>
 918:	b2 14       	cp	r11, r2
 91a:	60 f4       	brcc	.+24     	; 0x934 <__stack+0x35>
 91c:	b6 01       	movw	r22, r12
 91e:	80 e2       	ldi	r24, 0x20	; 32
 920:	90 e0       	ldi	r25, 0x00	; 0
 922:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 926:	b3 94       	inc	r11
 928:	f7 cf       	rjmp	.-18     	; 0x918 <__stack+0x19>
 92a:	b2 14       	cp	r11, r2
 92c:	18 f4       	brcc	.+6      	; 0x934 <__stack+0x35>
 92e:	2b 18       	sub	r2, r11
 930:	02 c0       	rjmp	.+4      	; 0x936 <__stack+0x37>
 932:	98 2c       	mov	r9, r8
 934:	21 2c       	mov	r2, r1
 936:	a4 fe       	sbrs	r10, 4
 938:	10 c0       	rjmp	.+32     	; 0x95a <__stack+0x5b>
 93a:	b6 01       	movw	r22, r12
 93c:	80 e3       	ldi	r24, 0x30	; 48
 93e:	90 e0       	ldi	r25, 0x00	; 0
 940:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 944:	a2 fe       	sbrs	r10, 2
 946:	17 c0       	rjmp	.+46     	; 0x976 <__stack+0x77>
 948:	a1 fc       	sbrc	r10, 1
 94a:	03 c0       	rjmp	.+6      	; 0x952 <__stack+0x53>
 94c:	88 e7       	ldi	r24, 0x78	; 120
 94e:	90 e0       	ldi	r25, 0x00	; 0
 950:	02 c0       	rjmp	.+4      	; 0x956 <__stack+0x57>
 952:	88 e5       	ldi	r24, 0x58	; 88
 954:	90 e0       	ldi	r25, 0x00	; 0
 956:	b6 01       	movw	r22, r12
 958:	0c c0       	rjmp	.+24     	; 0x972 <__stack+0x73>
 95a:	8a 2d       	mov	r24, r10
 95c:	86 78       	andi	r24, 0x86	; 134
 95e:	59 f0       	breq	.+22     	; 0x976 <__stack+0x77>
 960:	a1 fe       	sbrs	r10, 1
 962:	02 c0       	rjmp	.+4      	; 0x968 <__stack+0x69>
 964:	8b e2       	ldi	r24, 0x2B	; 43
 966:	01 c0       	rjmp	.+2      	; 0x96a <__stack+0x6b>
 968:	80 e2       	ldi	r24, 0x20	; 32
 96a:	a7 fc       	sbrc	r10, 7
 96c:	8d e2       	ldi	r24, 0x2D	; 45
 96e:	b6 01       	movw	r22, r12
 970:	90 e0       	ldi	r25, 0x00	; 0
 972:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 976:	89 14       	cp	r8, r9
 978:	38 f4       	brcc	.+14     	; 0x988 <__stack+0x89>
 97a:	b6 01       	movw	r22, r12
 97c:	80 e3       	ldi	r24, 0x30	; 48
 97e:	90 e0       	ldi	r25, 0x00	; 0
 980:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 984:	9a 94       	dec	r9
 986:	f7 cf       	rjmp	.-18     	; 0x976 <__stack+0x77>
 988:	8a 94       	dec	r8
 98a:	f3 01       	movw	r30, r6
 98c:	e8 0d       	add	r30, r8
 98e:	f1 1d       	adc	r31, r1
 990:	80 81       	ld	r24, Z
 992:	b6 01       	movw	r22, r12
 994:	90 e0       	ldi	r25, 0x00	; 0
 996:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 99a:	81 10       	cpse	r8, r1
 99c:	f5 cf       	rjmp	.-22     	; 0x988 <__stack+0x89>
 99e:	22 20       	and	r2, r2
 9a0:	09 f4       	brne	.+2      	; 0x9a4 <__stack+0xa5>
 9a2:	42 ce       	rjmp	.-892    	; 0x628 <vfprintf+0x24>
 9a4:	b6 01       	movw	r22, r12
 9a6:	80 e2       	ldi	r24, 0x20	; 32
 9a8:	90 e0       	ldi	r25, 0x00	; 0
 9aa:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <fputc>
 9ae:	2a 94       	dec	r2
 9b0:	f6 cf       	rjmp	.-20     	; 0x99e <__stack+0x9f>
 9b2:	f6 01       	movw	r30, r12
 9b4:	86 81       	ldd	r24, Z+6	; 0x06
 9b6:	97 81       	ldd	r25, Z+7	; 0x07
 9b8:	02 c0       	rjmp	.+4      	; 0x9be <__stack+0xbf>
 9ba:	8f ef       	ldi	r24, 0xFF	; 255
 9bc:	9f ef       	ldi	r25, 0xFF	; 255
 9be:	2b 96       	adiw	r28, 0x0b	; 11
 9c0:	e2 e1       	ldi	r30, 0x12	; 18
 9c2:	0c 94 af 05 	jmp	0xb5e	; 0xb5e <__epilogue_restores__>

000009c6 <strnlen_P>:
 9c6:	fc 01       	movw	r30, r24
 9c8:	05 90       	lpm	r0, Z+
 9ca:	61 50       	subi	r22, 0x01	; 1
 9cc:	70 40       	sbci	r23, 0x00	; 0
 9ce:	01 10       	cpse	r0, r1
 9d0:	d8 f7       	brcc	.-10     	; 0x9c8 <strnlen_P+0x2>
 9d2:	80 95       	com	r24
 9d4:	90 95       	com	r25
 9d6:	8e 0f       	add	r24, r30
 9d8:	9f 1f       	adc	r25, r31
 9da:	08 95       	ret

000009dc <strnlen>:
 9dc:	fc 01       	movw	r30, r24
 9de:	61 50       	subi	r22, 0x01	; 1
 9e0:	70 40       	sbci	r23, 0x00	; 0
 9e2:	01 90       	ld	r0, Z+
 9e4:	01 10       	cpse	r0, r1
 9e6:	d8 f7       	brcc	.-10     	; 0x9de <strnlen+0x2>
 9e8:	80 95       	com	r24
 9ea:	90 95       	com	r25
 9ec:	8e 0f       	add	r24, r30
 9ee:	9f 1f       	adc	r25, r31
 9f0:	08 95       	ret

000009f2 <fputc>:
 9f2:	0f 93       	push	r16
 9f4:	1f 93       	push	r17
 9f6:	cf 93       	push	r28
 9f8:	df 93       	push	r29
 9fa:	fb 01       	movw	r30, r22
 9fc:	23 81       	ldd	r18, Z+3	; 0x03
 9fe:	21 fd       	sbrc	r18, 1
 a00:	03 c0       	rjmp	.+6      	; 0xa08 <fputc+0x16>
 a02:	8f ef       	ldi	r24, 0xFF	; 255
 a04:	9f ef       	ldi	r25, 0xFF	; 255
 a06:	2c c0       	rjmp	.+88     	; 0xa60 <fputc+0x6e>
 a08:	22 ff       	sbrs	r18, 2
 a0a:	16 c0       	rjmp	.+44     	; 0xa38 <fputc+0x46>
 a0c:	46 81       	ldd	r20, Z+6	; 0x06
 a0e:	57 81       	ldd	r21, Z+7	; 0x07
 a10:	24 81       	ldd	r18, Z+4	; 0x04
 a12:	35 81       	ldd	r19, Z+5	; 0x05
 a14:	42 17       	cp	r20, r18
 a16:	53 07       	cpc	r21, r19
 a18:	44 f4       	brge	.+16     	; 0xa2a <fputc+0x38>
 a1a:	a0 81       	ld	r26, Z
 a1c:	b1 81       	ldd	r27, Z+1	; 0x01
 a1e:	9d 01       	movw	r18, r26
 a20:	2f 5f       	subi	r18, 0xFF	; 255
 a22:	3f 4f       	sbci	r19, 0xFF	; 255
 a24:	31 83       	std	Z+1, r19	; 0x01
 a26:	20 83       	st	Z, r18
 a28:	8c 93       	st	X, r24
 a2a:	26 81       	ldd	r18, Z+6	; 0x06
 a2c:	37 81       	ldd	r19, Z+7	; 0x07
 a2e:	2f 5f       	subi	r18, 0xFF	; 255
 a30:	3f 4f       	sbci	r19, 0xFF	; 255
 a32:	37 83       	std	Z+7, r19	; 0x07
 a34:	26 83       	std	Z+6, r18	; 0x06
 a36:	14 c0       	rjmp	.+40     	; 0xa60 <fputc+0x6e>
 a38:	8b 01       	movw	r16, r22
 a3a:	ec 01       	movw	r28, r24
 a3c:	fb 01       	movw	r30, r22
 a3e:	00 84       	ldd	r0, Z+8	; 0x08
 a40:	f1 85       	ldd	r31, Z+9	; 0x09
 a42:	e0 2d       	mov	r30, r0
 a44:	09 95       	icall
 a46:	89 2b       	or	r24, r25
 a48:	e1 f6       	brne	.-72     	; 0xa02 <fputc+0x10>
 a4a:	d8 01       	movw	r26, r16
 a4c:	16 96       	adiw	r26, 0x06	; 6
 a4e:	8d 91       	ld	r24, X+
 a50:	9c 91       	ld	r25, X
 a52:	17 97       	sbiw	r26, 0x07	; 7
 a54:	01 96       	adiw	r24, 0x01	; 1
 a56:	17 96       	adiw	r26, 0x07	; 7
 a58:	9c 93       	st	X, r25
 a5a:	8e 93       	st	-X, r24
 a5c:	16 97       	sbiw	r26, 0x06	; 6
 a5e:	ce 01       	movw	r24, r28
 a60:	df 91       	pop	r29
 a62:	cf 91       	pop	r28
 a64:	1f 91       	pop	r17
 a66:	0f 91       	pop	r16
 a68:	08 95       	ret

00000a6a <__ultoa_invert>:
 a6a:	fa 01       	movw	r30, r20
 a6c:	aa 27       	eor	r26, r26
 a6e:	28 30       	cpi	r18, 0x08	; 8
 a70:	51 f1       	breq	.+84     	; 0xac6 <__ultoa_invert+0x5c>
 a72:	20 31       	cpi	r18, 0x10	; 16
 a74:	81 f1       	breq	.+96     	; 0xad6 <__ultoa_invert+0x6c>
 a76:	e8 94       	clt
 a78:	6f 93       	push	r22
 a7a:	6e 7f       	andi	r22, 0xFE	; 254
 a7c:	6e 5f       	subi	r22, 0xFE	; 254
 a7e:	7f 4f       	sbci	r23, 0xFF	; 255
 a80:	8f 4f       	sbci	r24, 0xFF	; 255
 a82:	9f 4f       	sbci	r25, 0xFF	; 255
 a84:	af 4f       	sbci	r26, 0xFF	; 255
 a86:	b1 e0       	ldi	r27, 0x01	; 1
 a88:	3e d0       	rcall	.+124    	; 0xb06 <__ultoa_invert+0x9c>
 a8a:	b4 e0       	ldi	r27, 0x04	; 4
 a8c:	3c d0       	rcall	.+120    	; 0xb06 <__ultoa_invert+0x9c>
 a8e:	67 0f       	add	r22, r23
 a90:	78 1f       	adc	r23, r24
 a92:	89 1f       	adc	r24, r25
 a94:	9a 1f       	adc	r25, r26
 a96:	a1 1d       	adc	r26, r1
 a98:	68 0f       	add	r22, r24
 a9a:	79 1f       	adc	r23, r25
 a9c:	8a 1f       	adc	r24, r26
 a9e:	91 1d       	adc	r25, r1
 aa0:	a1 1d       	adc	r26, r1
 aa2:	6a 0f       	add	r22, r26
 aa4:	71 1d       	adc	r23, r1
 aa6:	81 1d       	adc	r24, r1
 aa8:	91 1d       	adc	r25, r1
 aaa:	a1 1d       	adc	r26, r1
 aac:	20 d0       	rcall	.+64     	; 0xaee <__ultoa_invert+0x84>
 aae:	09 f4       	brne	.+2      	; 0xab2 <__ultoa_invert+0x48>
 ab0:	68 94       	set
 ab2:	3f 91       	pop	r19
 ab4:	2a e0       	ldi	r18, 0x0A	; 10
 ab6:	26 9f       	mul	r18, r22
 ab8:	11 24       	eor	r1, r1
 aba:	30 19       	sub	r19, r0
 abc:	30 5d       	subi	r19, 0xD0	; 208
 abe:	31 93       	st	Z+, r19
 ac0:	de f6       	brtc	.-74     	; 0xa78 <__ultoa_invert+0xe>
 ac2:	cf 01       	movw	r24, r30
 ac4:	08 95       	ret
 ac6:	46 2f       	mov	r20, r22
 ac8:	47 70       	andi	r20, 0x07	; 7
 aca:	40 5d       	subi	r20, 0xD0	; 208
 acc:	41 93       	st	Z+, r20
 ace:	b3 e0       	ldi	r27, 0x03	; 3
 ad0:	0f d0       	rcall	.+30     	; 0xaf0 <__ultoa_invert+0x86>
 ad2:	c9 f7       	brne	.-14     	; 0xac6 <__ultoa_invert+0x5c>
 ad4:	f6 cf       	rjmp	.-20     	; 0xac2 <__ultoa_invert+0x58>
 ad6:	46 2f       	mov	r20, r22
 ad8:	4f 70       	andi	r20, 0x0F	; 15
 ada:	40 5d       	subi	r20, 0xD0	; 208
 adc:	4a 33       	cpi	r20, 0x3A	; 58
 ade:	18 f0       	brcs	.+6      	; 0xae6 <__ultoa_invert+0x7c>
 ae0:	49 5d       	subi	r20, 0xD9	; 217
 ae2:	31 fd       	sbrc	r19, 1
 ae4:	40 52       	subi	r20, 0x20	; 32
 ae6:	41 93       	st	Z+, r20
 ae8:	02 d0       	rcall	.+4      	; 0xaee <__ultoa_invert+0x84>
 aea:	a9 f7       	brne	.-22     	; 0xad6 <__ultoa_invert+0x6c>
 aec:	ea cf       	rjmp	.-44     	; 0xac2 <__ultoa_invert+0x58>
 aee:	b4 e0       	ldi	r27, 0x04	; 4
 af0:	a6 95       	lsr	r26
 af2:	97 95       	ror	r25
 af4:	87 95       	ror	r24
 af6:	77 95       	ror	r23
 af8:	67 95       	ror	r22
 afa:	ba 95       	dec	r27
 afc:	c9 f7       	brne	.-14     	; 0xaf0 <__ultoa_invert+0x86>
 afe:	00 97       	sbiw	r24, 0x00	; 0
 b00:	61 05       	cpc	r22, r1
 b02:	71 05       	cpc	r23, r1
 b04:	08 95       	ret
 b06:	9b 01       	movw	r18, r22
 b08:	ac 01       	movw	r20, r24
 b0a:	0a 2e       	mov	r0, r26
 b0c:	06 94       	lsr	r0
 b0e:	57 95       	ror	r21
 b10:	47 95       	ror	r20
 b12:	37 95       	ror	r19
 b14:	27 95       	ror	r18
 b16:	ba 95       	dec	r27
 b18:	c9 f7       	brne	.-14     	; 0xb0c <__ultoa_invert+0xa2>
 b1a:	62 0f       	add	r22, r18
 b1c:	73 1f       	adc	r23, r19
 b1e:	84 1f       	adc	r24, r20
 b20:	95 1f       	adc	r25, r21
 b22:	a0 1d       	adc	r26, r0
 b24:	08 95       	ret

00000b26 <__prologue_saves__>:
 b26:	2f 92       	push	r2
 b28:	3f 92       	push	r3
 b2a:	4f 92       	push	r4
 b2c:	5f 92       	push	r5
 b2e:	6f 92       	push	r6
 b30:	7f 92       	push	r7
 b32:	8f 92       	push	r8
 b34:	9f 92       	push	r9
 b36:	af 92       	push	r10
 b38:	bf 92       	push	r11
 b3a:	cf 92       	push	r12
 b3c:	df 92       	push	r13
 b3e:	ef 92       	push	r14
 b40:	ff 92       	push	r15
 b42:	0f 93       	push	r16
 b44:	1f 93       	push	r17
 b46:	cf 93       	push	r28
 b48:	df 93       	push	r29
 b4a:	cd b7       	in	r28, 0x3d	; 61
 b4c:	de b7       	in	r29, 0x3e	; 62
 b4e:	ca 1b       	sub	r28, r26
 b50:	db 0b       	sbc	r29, r27
 b52:	0f b6       	in	r0, 0x3f	; 63
 b54:	f8 94       	cli
 b56:	de bf       	out	0x3e, r29	; 62
 b58:	0f be       	out	0x3f, r0	; 63
 b5a:	cd bf       	out	0x3d, r28	; 61
 b5c:	09 94       	ijmp

00000b5e <__epilogue_restores__>:
 b5e:	2a 88       	ldd	r2, Y+18	; 0x12
 b60:	39 88       	ldd	r3, Y+17	; 0x11
 b62:	48 88       	ldd	r4, Y+16	; 0x10
 b64:	5f 84       	ldd	r5, Y+15	; 0x0f
 b66:	6e 84       	ldd	r6, Y+14	; 0x0e
 b68:	7d 84       	ldd	r7, Y+13	; 0x0d
 b6a:	8c 84       	ldd	r8, Y+12	; 0x0c
 b6c:	9b 84       	ldd	r9, Y+11	; 0x0b
 b6e:	aa 84       	ldd	r10, Y+10	; 0x0a
 b70:	b9 84       	ldd	r11, Y+9	; 0x09
 b72:	c8 84       	ldd	r12, Y+8	; 0x08
 b74:	df 80       	ldd	r13, Y+7	; 0x07
 b76:	ee 80       	ldd	r14, Y+6	; 0x06
 b78:	fd 80       	ldd	r15, Y+5	; 0x05
 b7a:	0c 81       	ldd	r16, Y+4	; 0x04
 b7c:	1b 81       	ldd	r17, Y+3	; 0x03
 b7e:	aa 81       	ldd	r26, Y+2	; 0x02
 b80:	b9 81       	ldd	r27, Y+1	; 0x01
 b82:	ce 0f       	add	r28, r30
 b84:	d1 1d       	adc	r29, r1
 b86:	0f b6       	in	r0, 0x3f	; 63
 b88:	f8 94       	cli
 b8a:	de bf       	out	0x3e, r29	; 62
 b8c:	0f be       	out	0x3f, r0	; 63
 b8e:	cd bf       	out	0x3d, r28	; 61
 b90:	ed 01       	movw	r28, r26
 b92:	08 95       	ret

00000b94 <_exit>:
 b94:	f8 94       	cli

00000b96 <__stop_program>:
 b96:	ff cf       	rjmp	.-2      	; 0xb96 <__stop_program>
