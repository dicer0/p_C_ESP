
6_Interrupciones.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000060  00800100  00000732  000007c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000732  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800160  00800160  00000826  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000826  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000858  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000d8  00000000  00000000  00000898  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001dd7  00000000  00000000  00000970  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007b6  00000000  00000000  00002747  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009c8  00000000  00000000  00002efd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000280  00000000  00000000  000038c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000525  00000000  00000000  00003b48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001448  00000000  00000000  0000406d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  000054b5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 59 02 	jmp	0x4b2	; 0x4b2 <__vector_1>
   8:	0c 94 a6 02 	jmp	0x54c	; 0x54c <__vector_2>
   c:	0c 94 f3 02 	jmp	0x5e6	; 0x5e6 <__vector_3>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e3       	ldi	r30, 0x32	; 50
  7c:	f7 e0       	ldi	r31, 0x07	; 7
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 36       	cpi	r26, 0x60	; 96
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 e6       	ldi	r26, 0x60	; 96
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a2 36       	cpi	r26, 0x62	; 98
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 40 03 	call	0x680	; 0x680 <main>
  9e:	0c 94 97 03 	jmp	0x72e	; 0x72e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ENVIA_CMD>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  a6:	98 2f       	mov	r25, r24
  a8:	90 7f       	andi	r25, 0xF0	; 240
  aa:	96 95       	lsr	r25
  ac:	96 95       	lsr	r25
  ae:	98 b9       	out	0x08, r25	; 8
  b0:	98 b1       	in	r25, 0x08	; 8
  b2:	9e 7f       	andi	r25, 0xFE	; 254
  b4:	98 b9       	out	0x08, r25	; 8
  b6:	98 b1       	in	r25, 0x08	; 8
  b8:	92 60       	ori	r25, 0x02	; 2
  ba:	98 b9       	out	0x08, r25	; 8
  bc:	ef e9       	ldi	r30, 0x9F	; 159
  be:	ff e0       	ldi	r31, 0x0F	; 15
  c0:	31 97       	sbiw	r30, 0x01	; 1
  c2:	f1 f7       	brne	.-4      	; 0xc0 <ENVIA_CMD+0x1a>
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <ENVIA_CMD+0x20>
  c6:	00 00       	nop
  c8:	98 b1       	in	r25, 0x08	; 8
  ca:	9d 7f       	andi	r25, 0xFD	; 253
  cc:	98 b9       	out	0x08, r25	; 8
  ce:	ef e3       	ldi	r30, 0x3F	; 63
  d0:	fc e9       	ldi	r31, 0x9C	; 156
  d2:	31 97       	sbiw	r30, 0x01	; 1
  d4:	f1 f7       	brne	.-4      	; 0xd2 <ENVIA_CMD+0x2c>
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <ENVIA_CMD+0x32>
  d8:	00 00       	nop
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	88 0f       	add	r24, r24
  de:	99 1f       	adc	r25, r25
  e0:	88 0f       	add	r24, r24
  e2:	99 1f       	adc	r25, r25
  e4:	8c 73       	andi	r24, 0x3C	; 60
  e6:	88 b9       	out	0x08, r24	; 8
  e8:	88 b1       	in	r24, 0x08	; 8
  ea:	8e 7f       	andi	r24, 0xFE	; 254
  ec:	88 b9       	out	0x08, r24	; 8
  ee:	88 b1       	in	r24, 0x08	; 8
  f0:	82 60       	ori	r24, 0x02	; 2
  f2:	88 b9       	out	0x08, r24	; 8
  f4:	8f e9       	ldi	r24, 0x9F	; 159
  f6:	9f e0       	ldi	r25, 0x0F	; 15
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	f1 f7       	brne	.-4      	; 0xf8 <ENVIA_CMD+0x52>
  fc:	00 c0       	rjmp	.+0      	; 0xfe <ENVIA_CMD+0x58>
  fe:	00 00       	nop
 100:	88 b1       	in	r24, 0x08	; 8
 102:	8d 7f       	andi	r24, 0xFD	; 253
 104:	88 b9       	out	0x08, r24	; 8
 106:	ef e3       	ldi	r30, 0x3F	; 63
 108:	fc e9       	ldi	r31, 0x9C	; 156
 10a:	31 97       	sbiw	r30, 0x01	; 1
 10c:	f1 f7       	brne	.-4      	; 0x10a <ENVIA_CMD+0x64>
 10e:	00 c0       	rjmp	.+0      	; 0x110 <ENVIA_CMD+0x6a>
 110:	00 00       	nop
 112:	08 95       	ret

00000114 <LCD_INICIALIZA>:
 114:	82 e0       	ldi	r24, 0x02	; 2
 116:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 11a:	88 e2       	ldi	r24, 0x28	; 40
 11c:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 120:	8e e0       	ldi	r24, 0x0E	; 14
 122:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 126:	86 e0       	ldi	r24, 0x06	; 6
 128:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 132:	80 e8       	ldi	r24, 0x80	; 128
 134:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 138:	08 95       	ret

0000013a <ENVIA_DATO>:
 13a:	98 2f       	mov	r25, r24
 13c:	90 7f       	andi	r25, 0xF0	; 240
 13e:	96 95       	lsr	r25
 140:	96 95       	lsr	r25
 142:	98 b9       	out	0x08, r25	; 8
 144:	98 b1       	in	r25, 0x08	; 8
 146:	93 60       	ori	r25, 0x03	; 3
 148:	98 b9       	out	0x08, r25	; 8
 14a:	ef e9       	ldi	r30, 0x9F	; 159
 14c:	ff e0       	ldi	r31, 0x0F	; 15
 14e:	31 97       	sbiw	r30, 0x01	; 1
 150:	f1 f7       	brne	.-4      	; 0x14e <ENVIA_DATO+0x14>
 152:	00 c0       	rjmp	.+0      	; 0x154 <ENVIA_DATO+0x1a>
 154:	00 00       	nop
 156:	98 b1       	in	r25, 0x08	; 8
 158:	9d 7f       	andi	r25, 0xFD	; 253
 15a:	98 b9       	out	0x08, r25	; 8
 15c:	98 b1       	in	r25, 0x08	; 8
 15e:	9e 7f       	andi	r25, 0xFE	; 254
 160:	98 b9       	out	0x08, r25	; 8
 162:	ef e3       	ldi	r30, 0x3F	; 63
 164:	fc e9       	ldi	r31, 0x9C	; 156
 166:	31 97       	sbiw	r30, 0x01	; 1
 168:	f1 f7       	brne	.-4      	; 0x166 <ENVIA_DATO+0x2c>
 16a:	00 c0       	rjmp	.+0      	; 0x16c <ENVIA_DATO+0x32>
 16c:	00 00       	nop
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	88 0f       	add	r24, r24
 172:	99 1f       	adc	r25, r25
 174:	88 0f       	add	r24, r24
 176:	99 1f       	adc	r25, r25
 178:	8c 73       	andi	r24, 0x3C	; 60
 17a:	88 b9       	out	0x08, r24	; 8
 17c:	88 b1       	in	r24, 0x08	; 8
 17e:	83 60       	ori	r24, 0x03	; 3
 180:	88 b9       	out	0x08, r24	; 8
 182:	8f e9       	ldi	r24, 0x9F	; 159
 184:	9f e0       	ldi	r25, 0x0F	; 15
 186:	01 97       	sbiw	r24, 0x01	; 1
 188:	f1 f7       	brne	.-4      	; 0x186 <ENVIA_DATO+0x4c>
 18a:	00 c0       	rjmp	.+0      	; 0x18c <ENVIA_DATO+0x52>
 18c:	00 00       	nop
 18e:	88 b1       	in	r24, 0x08	; 8
 190:	8d 7f       	andi	r24, 0xFD	; 253
 192:	88 b9       	out	0x08, r24	; 8
 194:	88 b1       	in	r24, 0x08	; 8
 196:	8e 7f       	andi	r24, 0xFE	; 254
 198:	88 b9       	out	0x08, r24	; 8
 19a:	ef e3       	ldi	r30, 0x3F	; 63
 19c:	fc e9       	ldi	r31, 0x9C	; 156
 19e:	31 97       	sbiw	r30, 0x01	; 1
 1a0:	f1 f7       	brne	.-4      	; 0x19e <ENVIA_DATO+0x64>
 1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <ENVIA_DATO+0x6a>
 1a4:	00 00       	nop
 1a6:	08 95       	ret

000001a8 <ENVIA_CADENA>:
 1a8:	0f 93       	push	r16
 1aa:	1f 93       	push	r17
 1ac:	cf 93       	push	r28
 1ae:	df 93       	push	r29
 1b0:	8c 01       	movw	r16, r24
 1b2:	c0 e0       	ldi	r28, 0x00	; 0
 1b4:	d0 e0       	ldi	r29, 0x00	; 0
 1b6:	03 c0       	rjmp	.+6      	; 0x1be <ENVIA_CADENA+0x16>
 1b8:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 1bc:	21 96       	adiw	r28, 0x01	; 1
 1be:	f8 01       	movw	r30, r16
 1c0:	ec 0f       	add	r30, r28
 1c2:	fd 1f       	adc	r31, r29
 1c4:	80 81       	ld	r24, Z
 1c6:	81 11       	cpse	r24, r1
 1c8:	f7 cf       	rjmp	.-18     	; 0x1b8 <ENVIA_CADENA+0x10>
 1ca:	df 91       	pop	r29
 1cc:	cf 91       	pop	r28
 1ce:	1f 91       	pop	r17
 1d0:	0f 91       	pop	r16
 1d2:	08 95       	ret

000001d4 <CAR_ESP0>:
 1d4:	80 e4       	ldi	r24, 0x40	; 64
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 1da:	8f e9       	ldi	r24, 0x9F	; 159
 1dc:	9f e0       	ldi	r25, 0x0F	; 15
 1de:	01 97       	sbiw	r24, 0x01	; 1
 1e0:	f1 f7       	brne	.-4      	; 0x1de <CAR_ESP0+0xa>
 1e2:	00 c0       	rjmp	.+0      	; 0x1e4 <CAR_ESP0+0x10>
 1e4:	00 00       	nop
 1e6:	80 e0       	ldi	r24, 0x00	; 0
 1e8:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 1ec:	8f e9       	ldi	r24, 0x9F	; 159
 1ee:	9f e0       	ldi	r25, 0x0F	; 15
 1f0:	01 97       	sbiw	r24, 0x01	; 1
 1f2:	f1 f7       	brne	.-4      	; 0x1f0 <CAR_ESP0+0x1c>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <CAR_ESP0+0x22>
 1f6:	00 00       	nop
 1f8:	8f e1       	ldi	r24, 0x1F	; 31
 1fa:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 1fe:	8f e9       	ldi	r24, 0x9F	; 159
 200:	9f e0       	ldi	r25, 0x0F	; 15
 202:	01 97       	sbiw	r24, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <CAR_ESP0+0x2e>
 206:	00 c0       	rjmp	.+0      	; 0x208 <CAR_ESP0+0x34>
 208:	00 00       	nop
 20a:	81 e1       	ldi	r24, 0x11	; 17
 20c:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 210:	8f e9       	ldi	r24, 0x9F	; 159
 212:	9f e0       	ldi	r25, 0x0F	; 15
 214:	01 97       	sbiw	r24, 0x01	; 1
 216:	f1 f7       	brne	.-4      	; 0x214 <CAR_ESP0+0x40>
 218:	00 c0       	rjmp	.+0      	; 0x21a <CAR_ESP0+0x46>
 21a:	00 00       	nop
 21c:	8b e1       	ldi	r24, 0x1B	; 27
 21e:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 222:	8f e9       	ldi	r24, 0x9F	; 159
 224:	9f e0       	ldi	r25, 0x0F	; 15
 226:	01 97       	sbiw	r24, 0x01	; 1
 228:	f1 f7       	brne	.-4      	; 0x226 <CAR_ESP0+0x52>
 22a:	00 c0       	rjmp	.+0      	; 0x22c <CAR_ESP0+0x58>
 22c:	00 00       	nop
 22e:	8e e0       	ldi	r24, 0x0E	; 14
 230:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 234:	8f e9       	ldi	r24, 0x9F	; 159
 236:	9f e0       	ldi	r25, 0x0F	; 15
 238:	01 97       	sbiw	r24, 0x01	; 1
 23a:	f1 f7       	brne	.-4      	; 0x238 <CAR_ESP0+0x64>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <CAR_ESP0+0x6a>
 23e:	00 00       	nop
 240:	84 e0       	ldi	r24, 0x04	; 4
 242:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 246:	8f e9       	ldi	r24, 0x9F	; 159
 248:	9f e0       	ldi	r25, 0x0F	; 15
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	f1 f7       	brne	.-4      	; 0x24a <CAR_ESP0+0x76>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <CAR_ESP0+0x7c>
 250:	00 00       	nop
 252:	80 e0       	ldi	r24, 0x00	; 0
 254:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 258:	8f e9       	ldi	r24, 0x9F	; 159
 25a:	9f e0       	ldi	r25, 0x0F	; 15
 25c:	01 97       	sbiw	r24, 0x01	; 1
 25e:	f1 f7       	brne	.-4      	; 0x25c <CAR_ESP0+0x88>
 260:	00 c0       	rjmp	.+0      	; 0x262 <CAR_ESP0+0x8e>
 262:	00 00       	nop
 264:	80 e0       	ldi	r24, 0x00	; 0
 266:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 26a:	8f e9       	ldi	r24, 0x9F	; 159
 26c:	9f e0       	ldi	r25, 0x0F	; 15
 26e:	01 97       	sbiw	r24, 0x01	; 1
 270:	f1 f7       	brne	.-4      	; 0x26e <CAR_ESP0+0x9a>
 272:	00 c0       	rjmp	.+0      	; 0x274 <CAR_ESP0+0xa0>
 274:	00 00       	nop
 276:	08 95       	ret

00000278 <CAR_ESP1>:
 278:	88 e4       	ldi	r24, 0x48	; 72
 27a:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 27e:	8f e9       	ldi	r24, 0x9F	; 159
 280:	9f e0       	ldi	r25, 0x0F	; 15
 282:	01 97       	sbiw	r24, 0x01	; 1
 284:	f1 f7       	brne	.-4      	; 0x282 <CAR_ESP1+0xa>
 286:	00 c0       	rjmp	.+0      	; 0x288 <CAR_ESP1+0x10>
 288:	00 00       	nop
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 290:	8f e9       	ldi	r24, 0x9F	; 159
 292:	9f e0       	ldi	r25, 0x0F	; 15
 294:	01 97       	sbiw	r24, 0x01	; 1
 296:	f1 f7       	brne	.-4      	; 0x294 <CAR_ESP1+0x1c>
 298:	00 c0       	rjmp	.+0      	; 0x29a <CAR_ESP1+0x22>
 29a:	00 00       	nop
 29c:	8a e0       	ldi	r24, 0x0A	; 10
 29e:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2a2:	8f e9       	ldi	r24, 0x9F	; 159
 2a4:	9f e0       	ldi	r25, 0x0F	; 15
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	f1 f7       	brne	.-4      	; 0x2a6 <CAR_ESP1+0x2e>
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <CAR_ESP1+0x34>
 2ac:	00 00       	nop
 2ae:	8a e0       	ldi	r24, 0x0A	; 10
 2b0:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2b4:	8f e9       	ldi	r24, 0x9F	; 159
 2b6:	9f e0       	ldi	r25, 0x0F	; 15
 2b8:	01 97       	sbiw	r24, 0x01	; 1
 2ba:	f1 f7       	brne	.-4      	; 0x2b8 <CAR_ESP1+0x40>
 2bc:	00 c0       	rjmp	.+0      	; 0x2be <CAR_ESP1+0x46>
 2be:	00 00       	nop
 2c0:	8a e0       	ldi	r24, 0x0A	; 10
 2c2:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2c6:	8f e9       	ldi	r24, 0x9F	; 159
 2c8:	9f e0       	ldi	r25, 0x0F	; 15
 2ca:	01 97       	sbiw	r24, 0x01	; 1
 2cc:	f1 f7       	brne	.-4      	; 0x2ca <CAR_ESP1+0x52>
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <CAR_ESP1+0x58>
 2d0:	00 00       	nop
 2d2:	80 e0       	ldi	r24, 0x00	; 0
 2d4:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2d8:	8f e9       	ldi	r24, 0x9F	; 159
 2da:	9f e0       	ldi	r25, 0x0F	; 15
 2dc:	01 97       	sbiw	r24, 0x01	; 1
 2de:	f1 f7       	brne	.-4      	; 0x2dc <CAR_ESP1+0x64>
 2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <CAR_ESP1+0x6a>
 2e2:	00 00       	nop
 2e4:	81 e1       	ldi	r24, 0x11	; 17
 2e6:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2ea:	8f e9       	ldi	r24, 0x9F	; 159
 2ec:	9f e0       	ldi	r25, 0x0F	; 15
 2ee:	01 97       	sbiw	r24, 0x01	; 1
 2f0:	f1 f7       	brne	.-4      	; 0x2ee <CAR_ESP1+0x76>
 2f2:	00 c0       	rjmp	.+0      	; 0x2f4 <CAR_ESP1+0x7c>
 2f4:	00 00       	nop
 2f6:	8e e0       	ldi	r24, 0x0E	; 14
 2f8:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 2fc:	8f e9       	ldi	r24, 0x9F	; 159
 2fe:	9f e0       	ldi	r25, 0x0F	; 15
 300:	01 97       	sbiw	r24, 0x01	; 1
 302:	f1 f7       	brne	.-4      	; 0x300 <CAR_ESP1+0x88>
 304:	00 c0       	rjmp	.+0      	; 0x306 <CAR_ESP1+0x8e>
 306:	00 00       	nop
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 30e:	8f e9       	ldi	r24, 0x9F	; 159
 310:	9f e0       	ldi	r25, 0x0F	; 15
 312:	01 97       	sbiw	r24, 0x01	; 1
 314:	f1 f7       	brne	.-4      	; 0x312 <CAR_ESP1+0x9a>
 316:	00 c0       	rjmp	.+0      	; 0x318 <CAR_ESP1+0xa0>
 318:	00 00       	nop
 31a:	08 95       	ret

0000031c <CAR_ESP2>:
 31c:	80 e5       	ldi	r24, 0x50	; 80
 31e:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 322:	8f e9       	ldi	r24, 0x9F	; 159
 324:	9f e0       	ldi	r25, 0x0F	; 15
 326:	01 97       	sbiw	r24, 0x01	; 1
 328:	f1 f7       	brne	.-4      	; 0x326 <CAR_ESP2+0xa>
 32a:	00 c0       	rjmp	.+0      	; 0x32c <CAR_ESP2+0x10>
 32c:	00 00       	nop
 32e:	80 e0       	ldi	r24, 0x00	; 0
 330:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 334:	8f e9       	ldi	r24, 0x9F	; 159
 336:	9f e0       	ldi	r25, 0x0F	; 15
 338:	01 97       	sbiw	r24, 0x01	; 1
 33a:	f1 f7       	brne	.-4      	; 0x338 <CAR_ESP2+0x1c>
 33c:	00 c0       	rjmp	.+0      	; 0x33e <CAR_ESP2+0x22>
 33e:	00 00       	nop
 340:	80 e0       	ldi	r24, 0x00	; 0
 342:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 346:	8f e9       	ldi	r24, 0x9F	; 159
 348:	9f e0       	ldi	r25, 0x0F	; 15
 34a:	01 97       	sbiw	r24, 0x01	; 1
 34c:	f1 f7       	brne	.-4      	; 0x34a <CAR_ESP2+0x2e>
 34e:	00 c0       	rjmp	.+0      	; 0x350 <CAR_ESP2+0x34>
 350:	00 00       	nop
 352:	8b e1       	ldi	r24, 0x1B	; 27
 354:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 358:	8f e9       	ldi	r24, 0x9F	; 159
 35a:	9f e0       	ldi	r25, 0x0F	; 15
 35c:	01 97       	sbiw	r24, 0x01	; 1
 35e:	f1 f7       	brne	.-4      	; 0x35c <CAR_ESP2+0x40>
 360:	00 c0       	rjmp	.+0      	; 0x362 <CAR_ESP2+0x46>
 362:	00 00       	nop
 364:	85 e1       	ldi	r24, 0x15	; 21
 366:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 36a:	8f e9       	ldi	r24, 0x9F	; 159
 36c:	9f e0       	ldi	r25, 0x0F	; 15
 36e:	01 97       	sbiw	r24, 0x01	; 1
 370:	f1 f7       	brne	.-4      	; 0x36e <CAR_ESP2+0x52>
 372:	00 c0       	rjmp	.+0      	; 0x374 <CAR_ESP2+0x58>
 374:	00 00       	nop
 376:	81 e1       	ldi	r24, 0x11	; 17
 378:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 37c:	8f e9       	ldi	r24, 0x9F	; 159
 37e:	9f e0       	ldi	r25, 0x0F	; 15
 380:	01 97       	sbiw	r24, 0x01	; 1
 382:	f1 f7       	brne	.-4      	; 0x380 <CAR_ESP2+0x64>
 384:	00 c0       	rjmp	.+0      	; 0x386 <CAR_ESP2+0x6a>
 386:	00 00       	nop
 388:	8a e0       	ldi	r24, 0x0A	; 10
 38a:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 38e:	8f e9       	ldi	r24, 0x9F	; 159
 390:	9f e0       	ldi	r25, 0x0F	; 15
 392:	01 97       	sbiw	r24, 0x01	; 1
 394:	f1 f7       	brne	.-4      	; 0x392 <CAR_ESP2+0x76>
 396:	00 c0       	rjmp	.+0      	; 0x398 <CAR_ESP2+0x7c>
 398:	00 00       	nop
 39a:	84 e0       	ldi	r24, 0x04	; 4
 39c:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 3a0:	8f e9       	ldi	r24, 0x9F	; 159
 3a2:	9f e0       	ldi	r25, 0x0F	; 15
 3a4:	01 97       	sbiw	r24, 0x01	; 1
 3a6:	f1 f7       	brne	.-4      	; 0x3a4 <CAR_ESP2+0x88>
 3a8:	00 c0       	rjmp	.+0      	; 0x3aa <CAR_ESP2+0x8e>
 3aa:	00 00       	nop
 3ac:	80 e0       	ldi	r24, 0x00	; 0
 3ae:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 3b2:	8f e9       	ldi	r24, 0x9F	; 159
 3b4:	9f e0       	ldi	r25, 0x0F	; 15
 3b6:	01 97       	sbiw	r24, 0x01	; 1
 3b8:	f1 f7       	brne	.-4      	; 0x3b6 <CAR_ESP2+0x9a>
 3ba:	00 c0       	rjmp	.+0      	; 0x3bc <CAR_ESP2+0xa0>
 3bc:	00 00       	nop
 3be:	08 95       	ret

000003c0 <CAR_ESP3>:
 3c0:	88 e5       	ldi	r24, 0x58	; 88
 3c2:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 3c6:	8f e9       	ldi	r24, 0x9F	; 159
 3c8:	9f e0       	ldi	r25, 0x0F	; 15
 3ca:	01 97       	sbiw	r24, 0x01	; 1
 3cc:	f1 f7       	brne	.-4      	; 0x3ca <CAR_ESP3+0xa>
 3ce:	00 c0       	rjmp	.+0      	; 0x3d0 <CAR_ESP3+0x10>
 3d0:	00 00       	nop
 3d2:	8f e1       	ldi	r24, 0x1F	; 31
 3d4:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 3d8:	8f e9       	ldi	r24, 0x9F	; 159
 3da:	9f e0       	ldi	r25, 0x0F	; 15
 3dc:	01 97       	sbiw	r24, 0x01	; 1
 3de:	f1 f7       	brne	.-4      	; 0x3dc <CAR_ESP3+0x1c>
 3e0:	00 c0       	rjmp	.+0      	; 0x3e2 <CAR_ESP3+0x22>
 3e2:	00 00       	nop
 3e4:	85 e1       	ldi	r24, 0x15	; 21
 3e6:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 3ea:	8f e9       	ldi	r24, 0x9F	; 159
 3ec:	9f e0       	ldi	r25, 0x0F	; 15
 3ee:	01 97       	sbiw	r24, 0x01	; 1
 3f0:	f1 f7       	brne	.-4      	; 0x3ee <CAR_ESP3+0x2e>
 3f2:	00 c0       	rjmp	.+0      	; 0x3f4 <CAR_ESP3+0x34>
 3f4:	00 00       	nop
 3f6:	8f e1       	ldi	r24, 0x1F	; 31
 3f8:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 3fc:	8f e9       	ldi	r24, 0x9F	; 159
 3fe:	9f e0       	ldi	r25, 0x0F	; 15
 400:	01 97       	sbiw	r24, 0x01	; 1
 402:	f1 f7       	brne	.-4      	; 0x400 <__EEPROM_REGION_LENGTH__>
 404:	00 c0       	rjmp	.+0      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
 406:	00 00       	nop
 408:	8f e1       	ldi	r24, 0x1F	; 31
 40a:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 40e:	8f e9       	ldi	r24, 0x9F	; 159
 410:	9f e0       	ldi	r25, 0x0F	; 15
 412:	01 97       	sbiw	r24, 0x01	; 1
 414:	f1 f7       	brne	.-4      	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
 416:	00 c0       	rjmp	.+0      	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
 418:	00 00       	nop
 41a:	8f e1       	ldi	r24, 0x1F	; 31
 41c:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 420:	8f e9       	ldi	r24, 0x9F	; 159
 422:	9f e0       	ldi	r25, 0x0F	; 15
 424:	01 97       	sbiw	r24, 0x01	; 1
 426:	f1 f7       	brne	.-4      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 428:	00 c0       	rjmp	.+0      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
 42a:	00 00       	nop
 42c:	8a e0       	ldi	r24, 0x0A	; 10
 42e:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 432:	8f e9       	ldi	r24, 0x9F	; 159
 434:	9f e0       	ldi	r25, 0x0F	; 15
 436:	01 97       	sbiw	r24, 0x01	; 1
 438:	f1 f7       	brne	.-4      	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
 43a:	00 c0       	rjmp	.+0      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
 43c:	00 00       	nop
 43e:	8a e0       	ldi	r24, 0x0A	; 10
 440:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 444:	8f e9       	ldi	r24, 0x9F	; 159
 446:	9f e0       	ldi	r25, 0x0F	; 15
 448:	01 97       	sbiw	r24, 0x01	; 1
 44a:	f1 f7       	brne	.-4      	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
 44c:	00 c0       	rjmp	.+0      	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
 44e:	00 00       	nop
 450:	8b e1       	ldi	r24, 0x1B	; 27
 452:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 456:	8f e9       	ldi	r24, 0x9F	; 159
 458:	9f e0       	ldi	r25, 0x0F	; 15
 45a:	01 97       	sbiw	r24, 0x01	; 1
 45c:	f1 f7       	brne	.-4      	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 45e:	00 c0       	rjmp	.+0      	; 0x460 <__EEPROM_REGION_LENGTH__+0x60>
 460:	00 00       	nop
 462:	08 95       	ret

00000464 <LIMPIA_LCD>:
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 46a:	08 95       	ret

0000046c <REGRESO_CASA>:
 46c:	82 e0       	ldi	r24, 0x02	; 2
 46e:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 472:	08 95       	ret

00000474 <POS_LINEA1>:
 474:	80 68       	ori	r24, 0x80	; 128
 476:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 47a:	08 95       	ret

0000047c <POS_LINEA2>:
 47c:	80 6c       	ori	r24, 0xC0	; 192
 47e:	0e 94 53 00 	call	0xa6	; 0xa6 <ENVIA_CMD>
 482:	08 95       	ret

00000484 <MENSAJE_INICIAL>:

//MENSAJE_INICIAL: Función normal para mostrar un mensaje inicial después o antes de que se haya presionado una interrupción.
void MENSAJE_INICIAL(){
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 484:	0e 94 8a 00 	call	0x114	; 0x114 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 488:	0e 94 32 02 	call	0x464	; 0x464 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 48c:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 490:	80 e0       	ldi	r24, 0x00	; 0
 492:	0e 94 3a 02 	call	0x474	; 0x474 <POS_LINEA1>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Presiona una");
 496:	84 e0       	ldi	r24, 0x04	; 4
 498:	91 e0       	ldi	r25, 0x01	; 1
 49a:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
	POS_LINEA2(0);
 49e:	80 e0       	ldi	r24, 0x00	; 0
 4a0:	0e 94 3e 02 	call	0x47c	; 0x47c <POS_LINEA2>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Interrupcion ");
 4a4:	81 e1       	ldi	r24, 0x11	; 17
 4a6:	91 e0       	ldi	r25, 0x01	; 1
 4a8:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 4ac:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
 4b0:	08 95       	ret

000004b2 <__vector_1>:
/*Las acciones de las interrupciones externas deben ser descritas en una función fuera del método main, estas reciben como parámetro lo siguiente:
	- INT0_vect: Interrupción externa 0 después de haber sido configurada con los registros EIMSK y EICRA, esta está asociada al pin 2 (PD2) del Puerto D en el Arduino
	- INT1_vect: Interrupción externa 1 después de haber sido configurada con los registros EIMSK y EICRA, esta está asociada al pin 3 (PD3) del Puerto D en el Arduino.*/
//ISR INTERRUPCIONES EXTERNAS:
//INTERRUPCIÓN EXTERNA INT0 DEL PUERTO D; INT0	(Pin 2 del Puerto D): Se imprime en pantalla nuestro nombre + 1 caracter especial.
ISR(INT0_vect){
 4b2:	1f 92       	push	r1
 4b4:	0f 92       	push	r0
 4b6:	0f b6       	in	r0, 0x3f	; 63
 4b8:	0f 92       	push	r0
 4ba:	11 24       	eor	r1, r1
 4bc:	2f 93       	push	r18
 4be:	3f 93       	push	r19
 4c0:	4f 93       	push	r20
 4c2:	5f 93       	push	r21
 4c4:	6f 93       	push	r22
 4c6:	7f 93       	push	r23
 4c8:	8f 93       	push	r24
 4ca:	9f 93       	push	r25
 4cc:	af 93       	push	r26
 4ce:	bf 93       	push	r27
 4d0:	ef 93       	push	r30
 4d2:	ff 93       	push	r31
 4d4:	2f ef       	ldi	r18, 0xFF	; 255
 4d6:	8e e9       	ldi	r24, 0x9E	; 158
 4d8:	94 e2       	ldi	r25, 0x24	; 36
 4da:	21 50       	subi	r18, 0x01	; 1
 4dc:	80 40       	sbci	r24, 0x00	; 0
 4de:	90 40       	sbci	r25, 0x00	; 0
 4e0:	e1 f7       	brne	.-8      	; 0x4da <__vector_1+0x28>
 4e2:	00 c0       	rjmp	.+0      	; 0x4e4 <__vector_1+0x32>
 4e4:	00 00       	nop
	_delay_ms(750); //Retraso antirebote
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 4e6:	0e 94 8a 00 	call	0x114	; 0x114 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 4ea:	0e 94 32 02 	call	0x464	; 0x464 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 4ee:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 4f2:	80 e0       	ldi	r24, 0x00	; 0
 4f4:	0e 94 3a 02 	call	0x474	; 0x474 <POS_LINEA1>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Nombre: Diego");
 4f8:	8f e1       	ldi	r24, 0x1F	; 31
 4fa:	91 e0       	ldi	r25, 0x01	; 1
 4fc:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
	POS_LINEA2(0);
 500:	80 e0       	ldi	r24, 0x00	; 0
 502:	0e 94 3e 02 	call	0x47c	; 0x47c <POS_LINEA2>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Caracter: ");
 506:	8d e2       	ldi	r24, 0x2D	; 45
 508:	91 e0       	ldi	r25, 0x01	; 1
 50a:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	//Se manda el caracter 4 a la función ENVIA_DATO() para que se muestre en la pantalla del LCD
	ENVIA_DATO(3); //Impresión del caracter persionalizado 4.- CARACTER PERSONALIZADO DE TÍO COSA
 50e:	83 e0       	ldi	r24, 0x03	; 3
 510:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 514:	2f ef       	ldi	r18, 0xFF	; 255
 516:	89 e6       	ldi	r24, 0x69	; 105
 518:	98 e1       	ldi	r25, 0x18	; 24
 51a:	21 50       	subi	r18, 0x01	; 1
 51c:	80 40       	sbci	r24, 0x00	; 0
 51e:	90 40       	sbci	r25, 0x00	; 0
 520:	e1 f7       	brne	.-8      	; 0x51a <__vector_1+0x68>
 522:	00 c0       	rjmp	.+0      	; 0x524 <__vector_1+0x72>
 524:	00 00       	nop
	_delay_ms(500); //Retraso de 10 milisegundos para evitar el rebote
	MENSAJE_INICIAL();
 526:	0e 94 42 02 	call	0x484	; 0x484 <MENSAJE_INICIAL>
	
}
 52a:	ff 91       	pop	r31
 52c:	ef 91       	pop	r30
 52e:	bf 91       	pop	r27
 530:	af 91       	pop	r26
 532:	9f 91       	pop	r25
 534:	8f 91       	pop	r24
 536:	7f 91       	pop	r23
 538:	6f 91       	pop	r22
 53a:	5f 91       	pop	r21
 53c:	4f 91       	pop	r20
 53e:	3f 91       	pop	r19
 540:	2f 91       	pop	r18
 542:	0f 90       	pop	r0
 544:	0f be       	out	0x3f, r0	; 63
 546:	0f 90       	pop	r0
 548:	1f 90       	pop	r1
 54a:	18 95       	reti

0000054c <__vector_2>:
//INTERRUPCIÓN EXTERNA INT1 DEL PUERTO D: INT1	(Pin 3 del Puerto D): Se imprime en pantalla nuestro apellido + 1 caracter especial distinto.
ISR(INT1_vect){
 54c:	1f 92       	push	r1
 54e:	0f 92       	push	r0
 550:	0f b6       	in	r0, 0x3f	; 63
 552:	0f 92       	push	r0
 554:	11 24       	eor	r1, r1
 556:	2f 93       	push	r18
 558:	3f 93       	push	r19
 55a:	4f 93       	push	r20
 55c:	5f 93       	push	r21
 55e:	6f 93       	push	r22
 560:	7f 93       	push	r23
 562:	8f 93       	push	r24
 564:	9f 93       	push	r25
 566:	af 93       	push	r26
 568:	bf 93       	push	r27
 56a:	ef 93       	push	r30
 56c:	ff 93       	push	r31
 56e:	2f ef       	ldi	r18, 0xFF	; 255
 570:	8e e9       	ldi	r24, 0x9E	; 158
 572:	94 e2       	ldi	r25, 0x24	; 36
 574:	21 50       	subi	r18, 0x01	; 1
 576:	80 40       	sbci	r24, 0x00	; 0
 578:	90 40       	sbci	r25, 0x00	; 0
 57a:	e1 f7       	brne	.-8      	; 0x574 <__vector_2+0x28>
 57c:	00 c0       	rjmp	.+0      	; 0x57e <__vector_2+0x32>
 57e:	00 00       	nop
	_delay_ms(750); //Retraso antirebote
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 580:	0e 94 8a 00 	call	0x114	; 0x114 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 584:	0e 94 32 02 	call	0x464	; 0x464 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 588:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 58c:	80 e0       	ldi	r24, 0x00	; 0
 58e:	0e 94 3a 02 	call	0x474	; 0x474 <POS_LINEA1>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Apell: Cervantes");
 592:	88 e3       	ldi	r24, 0x38	; 56
 594:	91 e0       	ldi	r25, 0x01	; 1
 596:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
	POS_LINEA2(0);
 59a:	80 e0       	ldi	r24, 0x00	; 0
 59c:	0e 94 3e 02 	call	0x47c	; 0x47c <POS_LINEA2>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Caracter: ");
 5a0:	8d e2       	ldi	r24, 0x2D	; 45
 5a2:	91 e0       	ldi	r25, 0x01	; 1
 5a4:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	//Se manda el caracter 2 a la función ENVIA_DATO() para que se muestre en la pantalla del LCD
	ENVIA_DATO(1); //Impresión del caracter persionalizado 2.- CARACTER PERSONALIZADO DE SONRISA
 5a8:	81 e0       	ldi	r24, 0x01	; 1
 5aa:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 5ae:	2f ef       	ldi	r18, 0xFF	; 255
 5b0:	89 e6       	ldi	r24, 0x69	; 105
 5b2:	98 e1       	ldi	r25, 0x18	; 24
 5b4:	21 50       	subi	r18, 0x01	; 1
 5b6:	80 40       	sbci	r24, 0x00	; 0
 5b8:	90 40       	sbci	r25, 0x00	; 0
 5ba:	e1 f7       	brne	.-8      	; 0x5b4 <__vector_2+0x68>
 5bc:	00 c0       	rjmp	.+0      	; 0x5be <__vector_2+0x72>
 5be:	00 00       	nop
	_delay_ms(500); //Retraso de 10 milisegundos para evitar el rebote
	MENSAJE_INICIAL();
 5c0:	0e 94 42 02 	call	0x484	; 0x484 <MENSAJE_INICIAL>
}
 5c4:	ff 91       	pop	r31
 5c6:	ef 91       	pop	r30
 5c8:	bf 91       	pop	r27
 5ca:	af 91       	pop	r26
 5cc:	9f 91       	pop	r25
 5ce:	8f 91       	pop	r24
 5d0:	7f 91       	pop	r23
 5d2:	6f 91       	pop	r22
 5d4:	5f 91       	pop	r21
 5d6:	4f 91       	pop	r20
 5d8:	3f 91       	pop	r19
 5da:	2f 91       	pop	r18
 5dc:	0f 90       	pop	r0
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	0f 90       	pop	r0
 5e2:	1f 90       	pop	r1
 5e4:	18 95       	reti

000005e6 <__vector_3>:
	- PCINT0_vect: Detecta una interrupción PCIB, osea cuando cualquier pin del puerto B que haya sido puesto como pin de interrupción, detecte algún cambio.
	- PCINT1_vect: Detecta una interrupción PCIC, osea cuando cualquier pin del puerto C que haya sido puesto como pin de interrupción, detecte algún cambio.
	- PCINT2_vect: Detecta una interrupción PCID, osea cuando cualquier pin del puerto D que haya sido puesto como pin de interrupción, detecte algún cambio.
Todos los pines de interrupción que pertenezcan a un mismo puerto ejecutarán la misma ISR para llevar a cabo su función, aunque sean pines distintos.*/
//INTERRUPCIÓN PCI PCINT0 DEL PUERTO B: PCINT0	(Pin 8 del Puerto B) y PCINT1	(Pin 9 del Puerto B): Se imprime en pantalla un mensaje + 1 caracter especial.
ISR(PCINT0_vect){
 5e6:	1f 92       	push	r1
 5e8:	0f 92       	push	r0
 5ea:	0f b6       	in	r0, 0x3f	; 63
 5ec:	0f 92       	push	r0
 5ee:	11 24       	eor	r1, r1
 5f0:	2f 93       	push	r18
 5f2:	3f 93       	push	r19
 5f4:	4f 93       	push	r20
 5f6:	5f 93       	push	r21
 5f8:	6f 93       	push	r22
 5fa:	7f 93       	push	r23
 5fc:	8f 93       	push	r24
 5fe:	9f 93       	push	r25
 600:	af 93       	push	r26
 602:	bf 93       	push	r27
 604:	ef 93       	push	r30
 606:	ff 93       	push	r31
 608:	2f ef       	ldi	r18, 0xFF	; 255
 60a:	8e e9       	ldi	r24, 0x9E	; 158
 60c:	94 e2       	ldi	r25, 0x24	; 36
 60e:	21 50       	subi	r18, 0x01	; 1
 610:	80 40       	sbci	r24, 0x00	; 0
 612:	90 40       	sbci	r25, 0x00	; 0
 614:	e1 f7       	brne	.-8      	; 0x60e <__vector_3+0x28>
 616:	00 c0       	rjmp	.+0      	; 0x618 <__vector_3+0x32>
 618:	00 00       	nop
	_delay_ms(750); //Retraso antirebote
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 61a:	0e 94 8a 00 	call	0x114	; 0x114 <LCD_INICIALIZA>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 61e:	0e 94 32 02 	call	0x464	; 0x464 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 622:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 626:	80 e0       	ldi	r24, 0x00	; 0
 628:	0e 94 3a 02 	call	0x474	; 0x474 <POS_LINEA1>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Ironman");
 62c:	89 e4       	ldi	r24, 0x49	; 73
 62e:	91 e0       	ldi	r25, 0x01	; 1
 630:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	/*POS_LINEA2: Se refiere a la segunda línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD.*/
	POS_LINEA2(0);
 634:	80 e0       	ldi	r24, 0x00	; 0
 636:	0e 94 3e 02 	call	0x47c	; 0x47c <POS_LINEA2>
	/*ENVIA_CADENA: Función que ejecuta varias veces la función ENVIA_DATO, específicamente hasta que se encuentre con un caracter vacío, osea cuando ya haya recorrido cada 
	letra o caracter de la palabra que recibe como parámetro. Recordemos que cada fila del LCD cuenta con solo 16 caracteres, hay que contarlos para que quepan.*/
	ENVIA_CADENA("Reactor arc: ");
 63a:	81 e5       	ldi	r24, 0x51	; 81
 63c:	91 e0       	ldi	r25, 0x01	; 1
 63e:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ENVIA_CADENA>
	//Se manda el caracter 1 a la función ENVIA_DATO() para que se muestre en la pantalla del LCD
	ENVIA_DATO(0); //Impresión del caracter persionalizado 1.- CARACTER PERSONALIZADO DE REACTOR ARC
 642:	80 e0       	ldi	r24, 0x00	; 0
 644:	0e 94 9d 00 	call	0x13a	; 0x13a <ENVIA_DATO>
 648:	2f ef       	ldi	r18, 0xFF	; 255
 64a:	89 e6       	ldi	r24, 0x69	; 105
 64c:	98 e1       	ldi	r25, 0x18	; 24
 64e:	21 50       	subi	r18, 0x01	; 1
 650:	80 40       	sbci	r24, 0x00	; 0
 652:	90 40       	sbci	r25, 0x00	; 0
 654:	e1 f7       	brne	.-8      	; 0x64e <__vector_3+0x68>
 656:	00 c0       	rjmp	.+0      	; 0x658 <__vector_3+0x72>
 658:	00 00       	nop
	_delay_ms(500); //Retraso de 10 milisegundos para evitar el rebote
	MENSAJE_INICIAL();
 65a:	0e 94 42 02 	call	0x484	; 0x484 <MENSAJE_INICIAL>
}
 65e:	ff 91       	pop	r31
 660:	ef 91       	pop	r30
 662:	bf 91       	pop	r27
 664:	af 91       	pop	r26
 666:	9f 91       	pop	r25
 668:	8f 91       	pop	r24
 66a:	7f 91       	pop	r23
 66c:	6f 91       	pop	r22
 66e:	5f 91       	pop	r21
 670:	4f 91       	pop	r20
 672:	3f 91       	pop	r19
 674:	2f 91       	pop	r18
 676:	0f 90       	pop	r0
 678:	0f be       	out	0x3f, r0	; 63
 67a:	0f 90       	pop	r0
 67c:	1f 90       	pop	r1
 67e:	18 95       	reti

00000680 <main>:
int main(void){
	/*CLI: Cuando se activa una CLI interruption, automáticamente el bit 7 del status register que es GI (General Interruption) se convierte en 0 lógico, lo que convierte a 
	las interrupciones en MI (Maskable Interrupt), esto en términos más simples significa que las interrupciones están activas:
		- Cuando GI tiene valor de 1 lógico no está activada ninguna interrupción, osea que es NMI, Non Maskable Interrupt.
		- Cuando GI tiene valor de 0 lógico está activada la interrupción, osea que es MI, Maskable Interrupt.*/
	cli(); //Evita cualquier interrupción que entre mientras se está ejecutando ya una o antes de programar la máquina, ya que termine, permite la ejecución de interrupciones.
 680:	f8 94       	cli
	
	
	//PROGRAMACIÓN DE LA MÁQUINA: Se indica por medio de los registros de función específica si los pines de los puertos B, C y D serán entradas o salidas.
	//0: Pin como entrada
	//1: Pin como salida
	DDRB = 0xFC; //0xFC = 1111 1100; Algunos pines del puerto B son entradas y otros salidas. Solo son entradas los que activen interrupciones.
 682:	8c ef       	ldi	r24, 0xFC	; 252
 684:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF; //Todos los pines del puerto C son salidas.
 686:	8f ef       	ldi	r24, 0xFF	; 255
 688:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x00; //Todos los pines del puerto D son entradas.
 68a:	1a b8       	out	0x0a, r1	; 10
		-	La instrucción |= lo que hace es asignar el valor 1 lógico a un bit específico de un número binario cualquiera sin afectar a los demás.
		-	La instrucción & es un AND, lo que crea es una máscara AND.
		-	La instrucción &= lo que hace es asignar el valor 0 lógico a un bit específico de un número binario cualquiera sin afectar a los demás.*/
	//MÁSCARA OR: Convierte en 1 todo lo que esté en contacto con los 1 de la máscara y deja pasar tal cual lo que esté en contacto con los 0 de la máscara.
	//MÁSCARA AND: Convierte en 0 todo lo que esté en contacto con los 0 de la máscara y deja pasar tal cual lo que esté en contacto con los 1 de la máscara.
	EIMSK |= (1<<INT0);	//Activación de la interrupción externa INT0 asociada al pin 2 (PD2) del Puerto D en el Arduino.
 68c:	8d b3       	in	r24, 0x1d	; 29
 68e:	81 60       	ori	r24, 0x01	; 1
 690:	8d bb       	out	0x1d, r24	; 29
	EIMSK |= (1<<INT1);	//Activación de la interrupción externa INT1 asociada al pin 3 (PD3) del Puerto D en el Arduino.
 692:	8d b3       	in	r24, 0x1d	; 29
 694:	82 60       	ori	r24, 0x02	; 2
 696:	8d bb       	out	0x1d, r24	; 29
		- ISC00: Bit 0 del registro EICRA, afecta a la interrupción externa INT0:
			- ISC01 = 0 y ISC00 = 0; Interrupción de nivel bajo, osea cuando la señal de factor externo se encuentra en 0 lógico.
			- ISC01 = 0 y ISC00 = 1; Interrupción con cambio de estado lógico en la señal, osea cuando la señal de factor externo cambia de 0 a 1 o 1 a 0.
			- ISC01 = 1 y ISC00 = 0; Interrupción de flanco de bajada, osea cuando la señal de factor externo cambia de 1 a 0.
			- ISC01 = 1 y ISC00 = 1; Interrupción de flanco de subida, osea cuando la señal de factor externo cambia de 0 a 1.*/
	EICRA |= (1<<ISC01)|(1<<ISC00); //INT0 del registro EIMSK configurada con los bits ISC01 e ISC00 del registro EICRA, activando la interrupción de flanco de subida.
 698:	e9 e6       	ldi	r30, 0x69	; 105
 69a:	f0 e0       	ldi	r31, 0x00	; 0
 69c:	80 81       	ld	r24, Z
 69e:	83 60       	ori	r24, 0x03	; 3
 6a0:	80 83       	st	Z, r24
	EICRA |= (1<<ISC11)|(1<<ISC10); //INT1 del registro EIMSK configurada con los bits ISC11 e ISC10 del registro EICRA, activando la interrupción de flanco de subida.
 6a2:	80 81       	ld	r24, Z
 6a4:	8c 60       	ori	r24, 0x0C	; 12
 6a6:	80 83       	st	Z, r24
		- PCIE0: Es el bit 0 del registro PCICR y permite que los pines del puerto B sean de interrupción.
		- PCIE1: Es el bit 1 del registro PCICR y permite que los pines del puerto C sean de interrupción.
		- PCIE2: Es el bit 2 del registro PCICR y permite que los pines del puerto D sean de interrupción.
	Cuando se le asigna 1 lógico a un bit del registro se permite a todos los pines del puerto que puedan convertirse en pines de interrupción, si se deja 0 lógico no se 
	podrán convertir a pines de interrupción y se quedarán todos como pines normales.*/
	PCICR |= (1<<PCIE0);	//Los pines del puertos B son pines de interrupción.
 6a8:	e8 e6       	ldi	r30, 0x68	; 104
 6aa:	f0 e0       	ldi	r31, 0x00	; 0
 6ac:	80 81       	ld	r24, Z
 6ae:	81 60       	ori	r24, 0x01	; 1
 6b0:	80 83       	st	Z, r24
				PCINT20, es el bit 4 del registro PCMSK2:	Pin 4	(PD4) del Arduino
				PCINT21, es el bit 5 del registro PCMSK2:	Pin 5	(PD5) del Arduino
				PCINT22, es el bit 6 del registro PCMSK2:	Pin 6	(PD6) del Arduino
				PCINT23, es el bit 7 del registro PCMSK2:	Pin 7	(PD7) del Arduino
	Cuando se le asigna 1 lógico a un bit del registro se convierte en pin de interrupción, si se deja 0 lógico se conserva como pin normal.*/
	PCMSK0 |= (1<<PCINT0)|(1<<PCINT1); //Los bits PCINT0 y PCINT1 asociados a los pines 8 y 9 del puerto B son pines de interrupción.
 6b2:	eb e6       	ldi	r30, 0x6B	; 107
 6b4:	f0 e0       	ldi	r31, 0x00	; 0
 6b6:	80 81       	ld	r24, Z
 6b8:	83 60       	ori	r24, 0x03	; 3
 6ba:	80 83       	st	Z, r24
	
	/*SEI: Cuando se activa una SEI interruption, automáticamente el bit 7 del status register (GI) se convierte en 1 lógico, lo que convierte a las interrupciones en NMI 
	(No Mask Interruption):
		- Cuando GI tiene valor de 1 lógico no está activada ninguna interrupción, osea que es NMI, Non Maskable Interrupt.
		- Cuando GI tiene valor de 0 lógico está activada la interrupción, osea que es MI, Maskable Interrupt.*/
	sei(); //Permite cualquier interrupción que entre ya después de haber programado la máquina y cuando haya terminado de ejecutarse una interrupción anterior.
 6bc:	78 94       	sei
	
	//EJECUCIÓN DEL PROGRAMA: Ya después de haber configurado las interrupciones es cuando se ejecuta la función del programa
	//MANEJO DE LCD:
	/*LCD_INICIALIZA: Función para configurar el LCD a que su cursor esté en el inicio, exista una comunicación de 4 bits, disponga de 2 líneas el LCD, sus caracteres sean de
	5X8 pixeles, su cursor sea visible y no parpadee, su incremenento de posición sea hacia la derecha, su pantalla esté estática y se manden datos al LCD, no comandos.*/
	LCD_INICIALIZA();
 6be:	0e 94 8a 00 	call	0x114	; 0x114 <LCD_INICIALIZA>
	//Inicialización de los caracteres personalizados:
	//Creación del caracter especial 0 en la memoria CGRAM, que es parte de la memoria CGROM, donde se almacenan todos los símbolos a mostrar.
	CAR_ESP0();
 6c2:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <CAR_ESP0>
	//Creación del caracter especial 1 en la memoria CGRAM, que es parte de la memoria CGROM, donde se almacenan todos los símbolos a mostrar.
	CAR_ESP1();
 6c6:	0e 94 3c 01 	call	0x278	; 0x278 <CAR_ESP1>
	//Creación del caracter especial 2 en la memoria CGRAM, que es parte de la memoria CGROM, donde se almacenan todos los símbolos a mostrar.
	CAR_ESP2();
 6ca:	0e 94 8e 01 	call	0x31c	; 0x31c <CAR_ESP2>
	//Creación del caracter especial 3 en la memoria CGRAM, que es parte de la memoria CGROM, donde se almacenan todos los símbolos a mostrar.
	CAR_ESP3();
 6ce:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <CAR_ESP3>
	//LIMPIA_LCD: Función que limpia el LCD, borrando su pantalla y regresando su cursor a su posición inicial.
	LIMPIA_LCD();
 6d2:	0e 94 32 02 	call	0x464	; 0x464 <LIMPIA_LCD>
	//REGRESO_CASA: Función que regresa el cursor a su posición inicial
	REGRESO_CASA();
 6d6:	0e 94 36 02 	call	0x46c	; 0x46c <REGRESO_CASA>
	/*POS_LINEA1: Se refiere a la primera línea de 16 caracteres que se ve cuando la pantalla esté estática o dinámica, en el parámetro de la función se indica después de cual 
	de los 16 caracteres empezará a imprimir en pantalla el mensaje en el LCD. Puede obviarse la instrucción POS_LINEA1() y funcionará el programa, pero las posiciones de las 
	demás posiciones si se deben indicar explícitamente.*/
	POS_LINEA1(0);
 6da:	80 e0       	ldi	r24, 0x00	; 0
 6dc:	0e 94 3a 02 	call	0x474	; 0x474 <POS_LINEA1>
	//MENSAJE_INICIAL: Función normal para mostrar un mensaje inicial después o antes de que se haya presionado una interrupción.
	MENSAJE_INICIAL();
 6e0:	0e 94 42 02 	call	0x484	; 0x484 <MENSAJE_INICIAL>
		//0: Pin como entrada
		//1: Pin como salida
		//DDRB = 0x3F = 0011 1111; Algunos pines del puerto B son entradas y otros salidas. Solo son entradas los que activen interrupciones.
		/*Indicación de los pines de salida, si se declaró como entrada alguno de los pines y se utiliza un 1 en el registro PORT, la entrada llegará al microcontrolador de 
		manera inversa a la original (resistencias pull-up), si se pone un 0 llegará de forma normal (resistencias pull-down). Funciona más o menos como una compuerta NOT.*/
		PORTB = a;	//0XD7 = 1101 0111; Esto sirve para prender y apagar leds en el puerto B turnándose entre ellos.
 6e4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <a>
 6e8:	85 b9       	out	0x05, r24	; 5
 6ea:	2f ef       	ldi	r18, 0xFF	; 255
 6ec:	84 e3       	ldi	r24, 0x34	; 52
 6ee:	9c e0       	ldi	r25, 0x0C	; 12
 6f0:	21 50       	subi	r18, 0x01	; 1
 6f2:	80 40       	sbci	r24, 0x00	; 0
 6f4:	90 40       	sbci	r25, 0x00	; 0
 6f6:	e1 f7       	brne	.-8      	; 0x6f0 <main+0x70>
 6f8:	00 c0       	rjmp	.+0      	; 0x6fa <main+0x7a>
 6fa:	00 00       	nop
		_delay_ms(250);
		PORTB = b;	//0XEB = 1110 1011; Esto sirve para prender y apagar leds en el puerto B turnándose entre ellos.
 6fc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 700:	85 b9       	out	0x05, r24	; 5
 702:	2f ef       	ldi	r18, 0xFF	; 255
 704:	84 e3       	ldi	r24, 0x34	; 52
 706:	9c e0       	ldi	r25, 0x0C	; 12
 708:	21 50       	subi	r18, 0x01	; 1
 70a:	80 40       	sbci	r24, 0x00	; 0
 70c:	90 40       	sbci	r25, 0x00	; 0
 70e:	e1 f7       	brne	.-8      	; 0x708 <main+0x88>
 710:	00 c0       	rjmp	.+0      	; 0x712 <main+0x92>
 712:	00 00       	nop
		_delay_ms(250);
		PORTB = c;	//0X00 = 0000 0000; Esto sirve para apagar todos los leds en el puerto B.
 714:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <__data_end>
 718:	85 b9       	out	0x05, r24	; 5
 71a:	2f ef       	ldi	r18, 0xFF	; 255
 71c:	84 e3       	ldi	r24, 0x34	; 52
 71e:	9c e0       	ldi	r25, 0x0C	; 12
 720:	21 50       	subi	r18, 0x01	; 1
 722:	80 40       	sbci	r24, 0x00	; 0
 724:	90 40       	sbci	r25, 0x00	; 0
 726:	e1 f7       	brne	.-8      	; 0x720 <main+0xa0>
 728:	00 c0       	rjmp	.+0      	; 0x72a <main+0xaa>
 72a:	00 00       	nop
 72c:	db cf       	rjmp	.-74     	; 0x6e4 <main+0x64>

0000072e <_exit>:
 72e:	f8 94       	cli

00000730 <__stop_program>:
 730:	ff cf       	rjmp	.-2      	; 0x730 <__stop_program>
